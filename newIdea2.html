<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Property Match Finder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #666;
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
            width: 100%;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2.2rem;
            margin-bottom: 8px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 0.9rem;
        }

        /* Property Match Finder Section */
        .match-finder-section {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            border-left: 4px solid #FF6B6B;
        }

        .match-finder-section h3 {
            margin-bottom: 20px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.3rem;
        }

        /* Dynamic Location Groups */
        .dynamic-locations {
            margin-bottom: 20px;
        }

        .dynamic-location-group {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            padding: 15px;
            border: 2px solid #e0e0e0;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .dynamic-location-group:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }

        .dynamic-location-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .dynamic-location-header h4 {
            color: #333;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1.1rem;
        }

        .remove-location {
            background: #FF6B6B;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 12px;
        }

        .dynamic-location-content {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 15px;
        }

        .location-input-group {
            margin-bottom: 12px;
            position: relative;
        }

        .location-input-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
            color: #555;
            font-size: 0.9rem;
        }

        .location-input-group input, .location-input-group select {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .location-input-group input:focus, .location-input-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .priority-slider {
            margin-top: 15px;
        }

        .priority-slider label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
            font-size: 0.9rem;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider-value {
            min-width: 40px;
            text-align: center;
            font-weight: bold;
            color: #667eea;
        }

        input[type="range"] {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: #e0e0e0;
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
        }

        .add-location-btn {
            background: linear-gradient(45deg, #4ECDC4, #44A08D);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 10px 20px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 0 auto;
            transition: all 0.3s ease;
        }

        .add-location-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.4);
        }

        .match-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
            flex-wrap: wrap;
        }

        .match-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .match-btn.primary {
            background: linear-gradient(45deg, #FF6B6B, #FF8E53);
            color: white;
        }

        .match-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }

        .match-btn.secondary {
            background: #f8f9fa;
            color: #333;
            border: 2px solid #e0e0e0;
        }

        .match-btn.secondary:hover {
            background: #e9ecef;
        }

        /* FILTER SECTION STYLES */
        .filter-section {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            border-left: 4px solid #667eea;
        }

        .filter-section h3 {
            margin-bottom: 12px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1rem;
        }

        .filter-row {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
            flex-wrap: wrap;
            align-items: flex-end;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            min-width: 130px;
            flex: 1;
        }

        .filter-group label {
            font-weight: 600;
            margin-bottom: 4px;
            color: #333;
            font-size: 0.85rem;
        }

        .filter-group input, .filter-group select {
            padding: 8px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 13px;
            transition: all 0.3s ease;
            background: white;
        }

        .filter-group input:focus, .filter-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .amenities-filter {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid #764ba2;
        }

        .amenities-filters-container {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .amenity-category {
            flex: 1;
            min-width: 200px;
        }

        .amenity-category h4 {
            margin-bottom: 8px;
            color: #333;
            font-size: 0.9rem;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 5px;
        }

        .amenity-checkboxes {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .amenity-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .amenity-checkbox input {
            margin: 0;
        }

        .amenity-checkbox label {
            font-size: 0.85rem;
            color: #333;
            cursor: pointer;
        }

        .filter-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 13px;
            transition: all 0.3s ease;
        }

        .primary-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .primary-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .secondary-btn {
            background: #f8f9fa;
            color: #333;
            border: 2px solid #e0e0e0;
        }

        .secondary-btn:hover {
            background: #e9ecef;
        }

        .success-btn {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
        }

        .success-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.4);
        }

        .warning-btn {
            background: linear-gradient(45deg, #ffc107, #fd7e14);
            color: white;
        }

        .warning-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.4);
        }

        .content-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: 600px;
        }

        .results-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px;
            overflow-y: auto;
            height: 600px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .map-container {
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            position: relative;
        }

        #map {
            height: 100%;
            width: 100%;
        }

        /* Search Bar Styles */
        .search-container {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            z-index: 10;
        }

        .search-box {
            display: flex;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .search-input {
            flex: 1;
            border: none;
            padding: 12px 16px;
            font-size: 16px;
            outline: none;
        }

        .search-button {
            background: #667eea;
            color: white;
            border: none;
            padding: 0 20px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .search-button:hover {
            background: #5a6fd8;
        }

        .property-card {
            background: white;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            cursor: pointer;
            border-left: 4px solid #667eea;
            position: relative;
        }
        
        .property-card.high-match {
            border-left: 4px solid #4ECDC4;
            background: linear-gradient(45deg, #f0fff0, #e6ffe6);
        }

        .property-card.medium-match {
            border-left: 4px solid #FFD700;
            background: linear-gradient(45deg, #fffaf0, #fff5e6);
        }

        .property-card.low-match {
            border-left: 4px solid #FF6B6B;
            background: linear-gradient(45deg, #fff0f0, #ffe6e6);
        }
        
        .property-card.top-listing {
            border: 2px solid #FFD700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
            position: relative;
        }
        
        .property-card.top-listing::before {
            content: "⭐ TOP LISTING";
            position: absolute;
            top: -10px;
            right: 10px;
            background: #FFD700;
            color: #333;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: bold;
            z-index: 1;
        }

        .property-name1{
            display:flex;
            justify-content: space-between;
        }

        .property-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        .property-name {
            font-size: 1.1rem;
            font-weight: bold;
            color: #333;
            margin-bottom: 6px;
        }

        .property-rent {
            font-size: 1rem;
            color: #667eea;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .property-details {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            margin-bottom: 8px;
        }

        .detail-tag {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 3px 6px;
            border-radius: 10px;
            font-size: 0.75rem;
            white-space: nowrap;
        }

        .property-amenities {
            display: flex;
            gap: 3px;
            margin-top: 6px;
            flex-wrap: wrap;
        }

        .amenity-tag-small {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.5rem;
            text-align: center;
        }

        .stats {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 12px;
            border-radius: 12px;
            margin-bottom: 15px;
            text-align: center;
        }

        .loading {
            text-align: center;
            padding: 15px;
            color: #667eea;
            font-weight: bold;
        }

        .error {
            background: #ffe6e6;
            color: #d63031;
            padding: 8px;
            border-radius: 8px;
            margin: 8px 0;
        }

        .status-message {
            background: #e3f2fd;
            color: #1976d2;
            padding: 8px 12px;
            border-radius: 8px;
            margin: 8px 0;
            border-left: 4px solid #1976d2;
            font-size: 0.9rem;
        }

        /* Match Score Indicator */
        .match-score {
            display: inline-block;
            background: linear-gradient(45deg, #4ECDC4, #44A08D);
            color: white;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-left: 10px;
        }

        .property-card .match-score {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 0.7rem;
        }

        /* Match Results Summary */
        .match-summary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            display: none;
        }

        .match-summary.active {
            display: block;
        }

        .match-summary h4 {
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .match-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .stat-item {
            text-align: center;
            padding: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.8rem;
            opacity: 0.9;
        }

        /* Property proximity info */
        .property-proximity {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #eee;
        }

        .proximity-item {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            margin-bottom: 4px;
            color: #666;
        }

        .proximity-distance {
            font-weight: bold;
            color: #667eea;
        }

        /* Address examples */
        .address-examples {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #4ECDC4;
        }

        .address-examples h5 {
            margin-bottom: 10px;
            color: #333;
        }

        .example-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }

        .example-item {
            font-size: 0.85rem;
            color: #666;
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            transition: background 0.3s;
        }

        .example-item:hover {
            background: #e9ecef;
        }

        /* Add to Important Locations Button */
        .add-to-important-btn {
            background: linear-gradient(45deg, #4ECDC4, #44A08D);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 10px;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.3s ease;
        }

        .add-to-important-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(78, 205, 196, 0.3);
        }

        /* Modal for selecting location type */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 20px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .modal-title {
            font-size: 1.2rem;
            font-weight: bold;
            color: #333;
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
        }

        .modal-body {
            margin-bottom: 20px;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .modal-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
        }

        .modal-btn.primary {
            background: #667eea;
            color: white;
        }

        .modal-btn.secondary {
            background: #f8f9fa;
            color: #333;
            border: 1px solid #e0e0e0;
        }

        /* Bounded Area Controls */
        .bounded-area-controls {
            position: absolute;
            bottom: 15px;
            left: 15px;
            z-index: 10;
            background: white;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            display: none;
            flex-direction: column;
            gap: 8px;
        }

        .bounded-area-controls.active {
            display: flex;
        }

        .bounded-area-btn {
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.3s ease;
        }

        .bounded-area-btn:hover {
            background: #5a6fd8;
        }

        .bounded-area-btn.active {
            background: #4ECDC4;
        }

        .bounded-area-btn.active:hover {
            background: #44A08D;
        }

        /* Top Listings Controls */
        .top-listings-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .top-listings-select {
            padding: 8px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: white;
            font-size: 14px;
        }

        .highlight-top-btn {
            background: linear-gradient(45deg, #FFD700, #FFA500);
            color: #333;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.3s ease;
        }

        .highlight-top-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
        }

        .clear-highlight-btn {
            background: #f8f9fa;
            color: #333;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 8px 16px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .clear-highlight-btn:hover {
            background: #e9ecef;
        }

        /* Autocomplete dropdown styling */
        .pac-container {
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border: none;
            margin-top: 5px;
        }

        .pac-item {
            padding: 8px 12px;
            border-bottom: 1px solid #f0f0f0;
            font-size: 14px;
        }

        .pac-item:hover {
            background-color: #f5f5f5;
        }

        .pac-item-selected {
            background-color: #e3f2fd;
        }

        .pac-icon {
            margin-top: 5px;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .content-area {
                grid-template-columns: 1fr;
                height: auto;
                gap: 12px;
            }

            /* Make map smaller on top */
            .map-container {
                height: 40vh;
                order: 1;
            }

            /* Make cards fill remaining space */
            .results-panel {
                height: 50vh;
                max-height: none;
                overflow-y: auto;
                order: 2;
            }

            .property-card {
                margin-bottom: 10px;
                padding: 12px;
            }

            .property-name {
                font-size: 1rem;
            }

            .property-rent {
                font-size: 0.9rem;
            }

            .property-details {
                gap: 2px;
            }

            .detail-tag {
                font-size: 0.65rem;
                padding: 2px 5px;
            }

            .amenity-tag-small {
                font-size: 0.6rem;
                padding: 2px 5px;
            }

            .dynamic-location-content {
                grid-template-columns: 1fr;
            }
            
            .match-actions {
                flex-direction: column;
            }
            
            .match-btn {
                width: 100%;
            }
            
            .search-container {
                position: relative;
                top: 0;
                left: 0;
                right: 0;
                margin-bottom: 10px;
            }
            
            .bounded-area-controls {
                bottom: 10px;
                left: 10px;
                right: 10px;
            }
            
            /* Filter section mobile adjustments */
            .filter-row {
                flex-direction: column;
            }
            
            .filter-group {
                min-width: 100%;
            }
            
            .amenities-filters-container {
                flex-direction: column;
            }
            
            .amenity-category {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div>
                <h1>🏠 Property Match Finder</h1>
                <p>Find your perfect home based on proximity to important locations</p>
            </div>
        </div>

        <!-- FILTER SECTION -->
        <div class="filter-section">
            <h3>🔍 Property Filters</h3>
            <div class="filter-row">
                <div class="filter-group">
                    <label>🏷️ Name</label>
                    <input type="text" id="filter_name" placeholder="Search by name...">
                </div>
                <div class="filter-group">
                    <label>📍 Address</label>
                    <input type="text" id="filter_address" placeholder="Search by address...">
                </div>
                <div class="filter-group">
                    <label>🛏️ BHK</label>
                    <select id="filter_bhk">
                        <option value="">All BHK</option>
                    </select>
                </div>
            </div>
            <div class="filter-row">
                <div class="filter-group">
                    <label>💰 Rent (Min)</label>
                    <input type="text" id="filter_rent_min" placeholder="e.g., 10k, 1.5L, 15000">
                </div>
                <div class="filter-group">
                    <label>💰 Rent (Max)</label>
                    <input type="text" id="filter_rent_max" placeholder="e.g., 50k, 3L, 30000">
                </div>
                <div class="filter-group">
                    <label>📐 Carpet Area (Min)</label>
                    <input type="number" id="filter_carArea_min" placeholder="Min sqft...">
                </div>
            </div>
            <div class="filter-row">
                <div class="filter-group">
                    <label>📐 Carpet Area (Max)</label>
                    <input type="number" id="filter_carArea_max" placeholder="Max sqft...">
                </div>
                <div class="filter-group">
                    <label>🚗 Parking (Total)</label>
                    <select id="filter_parking">
                        <option value="">All Parking</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label>🪑 Furnished</label>
                    <select id="filter_furnished">
                        <option value="">All Furnished</option>
                    </select>
                </div>
            </div>
            <div class="filter-row">
                <div class="filter-group">
                    <label>📌 Area</label>
                    <select id="filter_area">
                        <option value="">All Areas</option>
                    </select>
                </div>
            </div>

            <div class="amenities-filter" id="amenitiesFilterSection">
                <h3>✨ Amenities Filter</h3>
                <div class="amenities-filters-container">
                    <div class="amenity-category">
                        <h4>Inside Apartment</h4>
                        <div class="amenity-checkboxes" id="insideApartmentAmenities">
                            <!-- Checkboxes will be added dynamically -->
                        </div>
                    </div>
                    <div class="amenity-category">
                        <h4>Inside Premises</h4>
                        <div class="amenity-checkboxes" id="insidePremisesAmenities">
                            <!-- Checkboxes will be added dynamically -->
                        </div>
                    </div>
                </div>
            </div>

            <div class="filter-actions">
                <button class="filter-btn primary-btn" onclick="applyPropertyFilters()">Apply Filters</button>
                <button class="filter-btn secondary-btn" onclick="resetPropertyFilters()">Reset All Filters</button>
                <button class="filter-btn success-btn" onclick="refreshData()" id="refreshBtn">
                    🔄 Refresh Data
                </button>
            </div>
        </div>

        <!-- Property Match Finder Section -->
        <div class="match-finder-section">
            <h3>🎯 Set Your Important Locations</h3>
            
            <!-- Dynamic Location Groups -->
            <div class="dynamic-locations" id="dynamicLocations">
                <!-- Dynamic location groups will be added here -->
            </div>
            
            <button class="add-location-btn" onclick="addDynamicLocation()">
                ➕ Add Another Location
            </button>

            <div class="address-examples">
                <h5>💡 Example Addresses (Click to use):</h5>
                <div class="example-list">
                    <div class="example-item" onclick="useExample('Bandra Kurla Complex, Mumbai')">Bandra Kurla Complex, Mumbai</div>
                    <div class="example-item" onclick="useExample('Nariman Point, Mumbai')">Nariman Point, Mumbai</div>
                    <div class="example-item" onclick="useExample('Dhirubhai Ambani International School, Mumbai')">Dhirubhai Ambani School</div>
                    <div class="example-item" onclick="useExample('Jamnabai Narsee School, Juhu')">Jamnabai Narsee School</div>
                    <div class="example-item" onclick="useExample('Lilavati Hospital, Bandra')">Lilavati Hospital, Bandra</div>
                    <div class="example-item" onclick="useExample('Kokilaben Hospital, Andheri')">Kokilaben Hospital</div>
                </div>
            </div>

            <div class="match-actions">
                <button class="match-btn primary" onclick="findPropertyMatches()">
                    🔍 Find Matching Properties
                </button>
                <button class="match-btn secondary" onclick="resetMatchFinder()">
                    🔄 Reset
                </button>
            </div>
        </div>

        <!-- Match Results Summary -->
        <div class="match-summary" id="matchSummary">
            <h4>📊 Property Match Results</h4>
            <div class="match-stats">
                <div class="stat-item">
                    <div class="stat-value" id="totalProperties">0</div>
                    <div class="stat-label">Properties (60%+)</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="highMatches">0</div>
                    <div class="stat-label">High Matches</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="mediumMatches">0</div>
                    <div class="stat-label">Medium Matches</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="avgMatchScore">0%</div>
                    <div class="stat-label">Avg Match Score</div>
                </div>
            </div>
            
            <!-- Top Listings Controls -->
            <div class="top-listings-controls">
                <label for="topListingsCount">Show Top:</label>
                <select class="top-listings-select" id="topListingsCount">
                    <option value="5">Top 5</option>
                    <option value="10" selected>Top 10</option>
                    <option value="15">Top 15</option>
                    <option value="20">Top 20</option>
                    <option value="25">Top 25</option>
                </select>
                <button class="highlight-top-btn" onclick="highlightTopListings()">
                    ⭐ Highlight Top Listings
                </button>
                <button class="clear-highlight-btn" onclick="clearTopListingsHighlight()">
                    Clear Highlight
                </button>
            </div>
        </div>

        <!-- Content Area -->
        <div class="content-area">
            <div class="results-panel">
                <div class="stats" id="stats">
                    <strong>Enter your important locations to find matching properties</strong>
                </div>
                <div id="statusMessages"></div>
                <div id="results"></div>
            </div>
            <div class="map-container">
                <!-- Search Bar -->
                <div class="search-container">
                    <div class="search-box">
                        <input type="text" id="address-search" class="search-input" placeholder="Search for an address or place...">
                        <button class="search-button" onclick="searchAddress()">🔍</button>
                    </div>
                </div>
                
                <!-- Bounded Area Controls -->
                <div class="bounded-area-controls" id="boundedAreaControls">
                    <button class="bounded-area-btn" onclick="toggleBoundedArea()">
                        <span id="boundedAreaToggleText">🗺️ Show Bounded Area</span>
                    </button>
                    <button class="bounded-area-btn" id="filterInAreaBtn" onclick="toggleFilterInArea()">
                        <span id="filterInAreaText">📍 Show Only Properties in Area</span>
                    </button>
                </div>
                
                <div id="map"></div>
            </div>
        </div>
    </div>

    <!-- Modal for adding searched address to important locations -->
    <div class="modal" id="addLocationModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Add to Important Locations</div>
                <button class="close-modal" onclick="closeAddLocationModal()">&times;</button>
            </div>
            <div class="modal-body">
                <p>Add the searched address to your important locations:</p>
                <div class="location-input-group" style="margin-top: 15px;">
                    <label for="modal_location_type">Location Type</label>
                    <select id="modal_location_type">
                        <option value="office">🏢 Office</option>
                        <option value="school">🏫 School</option>
                        <option value="hospital">🏥 Hospital</option>
                        <option value="gym">💪 Gym/Fitness Center</option>
                        <option value="temple">🛕 Temple</option>
                        <option value="mosque">🕌 Mosque</option>
                        <option value="market">🛒 Market/Shopping</option>
                        <option value="park">🌳 Park/Recreation</option>
                        <option value="restaurant">🍽️ Restaurant/Food</option>
                        <option value="transport">🚇 Transport Hub</option>
                        <option value="other" selected>📍 Other Important Location</option>
                    </select>
                </div>
                <div class="location-input-group">
                    <label for="modal_location_priority">Priority</label>
                    <div class="slider-container">
                        <input type="range" id="modal_location_priority" min="1" max="10" value="5">
                        <span class="slider-value" id="modal_priority_value">5</span>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn secondary" onclick="closeAddLocationModal()">Cancel</button>
                <button class="modal-btn primary" onclick="addSearchedLocation()">Add Location</button>
            </div>
        </div>
    </div>

    <script>
        // Your published Google Sheets CSV URL
        const SHEETS_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTMjpsUGc_KrCMECutLvsLTLva3BOaOX8H4bvvE8XA7qRltqJjY3Y7_zgvwr2MsKIjCJquXHg6UsErg/pub?output=csv';
        
        // Location types and their icons
        const locationTypes = {
            'office': { icon: '🏢', label: 'Office' },
            'school': { icon: '🏫', label: 'School' },
            'hospital': { icon: '🏥', label: 'Hospital' },
            'gym': { icon: '💪', label: 'Gym/Fitness Center' },
            'temple': { icon: '🛕', label: 'Temple' },
            'mosque': { icon: '🕌', label: 'Mosque' },
            'market': { icon: '🛒', label: 'Market/Shopping' },
            'park': { icon: '🌳', label: 'Park/Recreation' },
            'restaurant': { icon: '🍽️', label: 'Restaurant/Food' },
            'transport': { icon: '🚇', label: 'Transport Hub' },
            'other': { icon: '📍', label: 'Other Important Location' }
        };

        // Define amenities for each category
        const amenities = {
            "Inside Apartment": [
                "Wardrobe", "Geyser", "Air conditioner", "TV", "Light/Fan"
            ],
            "Inside Premises": [
                "Play area", "Gym", "Swimming Pool", "Hall", "Jogging Track"
            ]
        };

        // Map variations for amenities to handle different naming in data
        const amenityVariations = {
            "Wardrobe": ["Wardrobe", "wardrobe", "Almirah", "almirah"],
            "Geyser": ["Geyser", "geyser", "Water Heater", "water heater"],
            "Air conditioner": ["Air conditioner", "AC", "ac", "Air Conditioner", "air conditioner"],
            "TV": ["TV", "tv", "Television", "television"],
            "Light/Fan": ["Light", "Fan", "light", "fan", "Light/Fan", "Light & Fan"],
            "Play area": ["Play area", "play area", "Play Area", "Games", "games", "Court", "court", "Sports", "sports", "Basketball", "Tennis", "Badminton"],
            "Gym": ["Gym", "gym", "Gymnasium", "gymnasium", "Fitness", "fitness"],
            "Swimming Pool": ["Swimming Pool", "swimming pool", "Pool", "pool"],
            "Hall": ["Hall", "hall", "Community Hall", "community hall"],
            "Jogging Track": ["Jogging Track", "jogging track", "Jogging track", "Track", "track", "Running Track"]
        };

        let map;
        let markers = [];
        let allData = [];
        let filteredData = [];
        let headers = [];
        let infoWindows = [];
        let geocoder;
        let autocomplete;
        let searchAutocomplete;
        let searchMarker;
        let currentSearchedAddress = '';
        
        // Property Match Finder variables
        let matchResults = [];
        let importantLocations = {}; // Now supports multiple locations per type
        let dynamicLocations = []; // For storing dynamic location inputs
        let dynamicAutocompletes = []; // Store autocomplete instances for dynamic location inputs
        
        // Bounded Area variables
        let boundedAreaPolygon = null;
        let isBoundedAreaVisible = false;
        let isFilterInAreaActive = false;
        let boundedAreaBounds = null;

        // Top Listings variables
        let topListingsHighlighted = false;
        let topListingsMarkers = [];

        // Initialize with one location by default
        document.addEventListener('DOMContentLoaded', function() {
            // Show welcome message
            showStatusMessage('Welcome! Enter your important locations to find matching properties.', 'success');
            
            // Add one initial location
            addDynamicLocation();
        });

        function findColumn(possibleNames) {
            for (let name of possibleNames) {
                const exactMatch = headers.find(h => h && h.toLowerCase() === name.toLowerCase());
                if (exactMatch) return exactMatch;
                
                const containsMatch = headers.find(h => h && h.toLowerCase().includes(name.toLowerCase()));
                if (containsMatch) return containsMatch;
            }
            return null;
        }
        
        function initMap() {
            showStatusMessage('Google Maps loaded successfully!', 'success');
            map = new google.maps.Map(document.getElementById('map'), {
                center: { lat: 19.0760, lng: 72.8777 }, // Mumbai coordinates
                zoom: 12,
                styles: [
                    {
                        featureType: "poi",
                        elementType: "labels",
                        stylers: [{ visibility: "off" }]
                    }
                ]
            });
            
            geocoder = new google.maps.Geocoder();
            
            // Initialize priority sliders
            initializePrioritySliders();
            
            // Initialize autocomplete for address inputs
            initAutocomplete();
            
            // Initialize search autocomplete
            initSearchAutocomplete();
            
            loadData();
        }

        // Initialize Google Places Autocomplete for all address inputs
        function initAutocomplete() {
            // Initialize autocomplete for any existing dynamic location inputs
            dynamicLocations.forEach(locationId => {
                const addressInput = document.getElementById(`${locationId}_address`);
                if (addressInput) {
                    initAutocompleteForInput(addressInput);
                }
            });
        }

        // Initialize autocomplete for a specific input element
        function initAutocompleteForInput(inputElement) {
            const autocomplete = new google.maps.places.Autocomplete(inputElement, {
                types: ['geocode', 'establishment'],
                componentRestrictions: { country: 'in' }
            });
            
            autocomplete.addListener('place_changed', function() {
                const place = autocomplete.getPlace();
                if (place.geometry) {
                    showStatusMessage(`Location set to: ${place.formatted_address}`, 'success');
                }
            });
            
            return autocomplete;
        }

        // Initialize search autocomplete
        function initSearchAutocomplete() {
            const searchInput = document.getElementById('address-search');
            searchAutocomplete = new google.maps.places.Autocomplete(searchInput, {
                types: ['geocode', 'establishment'],
                componentRestrictions: { country: 'in' }
            });
            
            searchAutocomplete.addListener('place_changed', function() {
                const place = searchAutocomplete.getPlace();
                if (place.geometry) {
                    // Center map on selected location
                    map.setCenter(place.geometry.location);
                    map.setZoom(15);
                    
                    // Add a marker for the searched location
                    if (searchMarker) {
                        searchMarker.setMap(null);
                    }
                    
                    searchMarker = new google.maps.Marker({
                        position: place.geometry.location,
                        map: map,
                        title: place.name,
                        icon: {
                            url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
                                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <circle cx="12" cy="12" r="10" fill="#FF6B6B" stroke="white" stroke-width="2"/>
                                    <text x="12" y="16" text-anchor="middle" font-size="10" fill="white" font-weight="bold">📍</text>
                                </svg>
                            `),
                            scaledSize: new google.maps.Size(24, 24),
                            anchor: new google.maps.Point(12, 12)
                        }
                    });
                    
                    // Store the searched address
                    currentSearchedAddress = place.formatted_address;
                    
                    // Show info window with place details and "Add to Important" button
                    const infoWindow = new google.maps.InfoWindow({
                        content: `
                            <div style="min-width: 200px;">
                                <h3 style="margin: 0 0 8px 0; color: #333;">${place.name}</h3>
                                <p style="margin: 0; color: #666;">${place.formatted_address}</p>
                                <button class="add-to-important-btn" onclick="openAddLocationModal('${place.formatted_address.replace(/'/g, "\\'")}')">
                                    ➕ Add to Important Locations
                                </button>
                            </div>
                        `
                    });
                    
                    infoWindow.open(map, searchMarker);
                    
                    showStatusMessage(`Showing location: ${place.name}`, 'success');
                }
            });
            
            // Add event listener for Enter key
            searchInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    searchAddress();
                }
            });
        }

        // Search for address
        function searchAddress() {
            const address = document.getElementById('address-search').value;
            if (!address) {
                showStatusMessage('Please enter an address to search.', 'warning');
                return;
            }
            
            geocoder.geocode({ address: address }, function(results, status) {
                if (status === 'OK' && results[0]) {
                    // Center map on searched location
                    map.setCenter(results[0].geometry.location);
                    map.setZoom(15);
                    
                    // Add a marker for the searched location
                    if (searchMarker) {
                        searchMarker.setMap(null);
                    }
                    
                    searchMarker = new google.maps.Marker({
                        position: results[0].geometry.location,
                        map: map,
                        title: address,
                        icon: {
                            url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
                                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <circle cx="12" cy="12" r="10" fill="#FF6B6B" stroke="white" stroke-width="2"/>
                                    <text x="12" y="16" text-anchor="middle" font-size="10" fill="white" font-weight="bold">📍</text>
                                </svg>
                            `),
                            scaledSize: new google.maps.Size(24, 24),
                            anchor: new google.maps.Point(12, 12)
                        }
                    });
                    
                    // Store the searched address
                    currentSearchedAddress = results[0].formatted_address;
                    
                    // Show info window with place details and "Add to Important" button
                    const infoWindow = new google.maps.InfoWindow({
                        content: `
                            <div style="min-width: 200px;">
                                <h3 style="margin: 0 0 8px 0; color: #333;">Searched Location</h3>
                                <p style="margin: 0; color: #666;">${results[0].formatted_address}</p>
                                <button class="add-to-important-btn" onclick="openAddLocationModal('${results[0].formatted_address.replace(/'/g, "\\'")}')">
                                    ➕ Add to Important Locations
                                </button>
                            </div>
                        `
                    });
                    
                    infoWindow.open(map, searchMarker);
                    
                    showStatusMessage(`Showing location: ${results[0].formatted_address}`, 'success');
                } else {
                    showStatusMessage('Location not found. Please try a different address.', 'error');
                }
            });
        }

        // Open modal to add searched location to important locations
        function openAddLocationModal(address) {
            currentSearchedAddress = address;
            document.getElementById('addLocationModal').style.display = 'flex';
            
            // Initialize modal slider
            const modalSlider = document.getElementById('modal_location_priority');
            const modalValueSpan = document.getElementById('modal_priority_value');
            modalSlider.addEventListener('input', function() {
                modalValueSpan.textContent = this.value;
            });
        }

        // Close the add location modal
        function closeAddLocationModal() {
            document.getElementById('addLocationModal').style.display = 'none';
        }

        // Add searched location to important locations
        function addSearchedLocation() {
            const type = document.getElementById('modal_location_type').value;
            const priority = parseInt(document.getElementById('modal_location_priority').value);
            
            // Add a new dynamic location
            addDynamicLocation();
            
            // Set the values for the new location
            setTimeout(() => {
                const lastLocationId = dynamicLocations[dynamicLocations.length - 1];
                const typeSelect = document.getElementById(`${lastLocationId}_type`);
                const addressInput = document.getElementById(`${lastLocationId}_address`);
                const prioritySlider = document.getElementById(`${lastLocationId}_priority`);
                const priorityValue = document.getElementById(`${lastLocationId}_priority_value`);
                
                if (typeSelect && addressInput && prioritySlider && priorityValue) {
                    typeSelect.value = type;
                    addressInput.value = currentSearchedAddress;
                    prioritySlider.value = priority;
                    priorityValue.textContent = priority;
                    
                    // Update the location icon
                    updateDynamicLocationIcon(lastLocationId);
                    
                    // Initialize autocomplete for the new address input
                    initAutocompleteForInput(addressInput);
                    
                    showStatusMessage(`Added "${currentSearchedAddress}" to important locations as ${locationTypes[type].label}`, 'success');
                }
            }, 100);
            
            closeAddLocationModal();
        }

        // Initialize priority sliders for Property Match Finder
        function initializePrioritySliders() {
            const sliders = document.querySelectorAll('.priority-slider');
            sliders.forEach(slider => {
                const valueSpan = slider.parentElement.querySelector('.slider-value');
                slider.addEventListener('input', function() {
                    valueSpan.textContent = this.value;
                });
            });
        }

        // Add a dynamic location input group
        function addDynamicLocation() {
            const dynamicLocationsDiv = document.getElementById('dynamicLocations');
            const locationId = 'dynamic_' + Date.now();
            
            const locationGroup = document.createElement('div');
            locationGroup.className = 'dynamic-location-group';
            locationGroup.id = locationId;
            
            locationGroup.innerHTML = `
                <div class="dynamic-location-header">
                    <h4>📍 Important Location</h4>
                    <button class="remove-location" onclick="removeDynamicLocation('${locationId}')">Remove</button>
                </div>
                <div class="dynamic-location-content">
                    <div class="location-input-group">
                        <label for="${locationId}_type">Location Type</label>
                        <select id="${locationId}_type" onchange="updateDynamicLocationIcon('${locationId}')">
                            ${Object.keys(locationTypes).map(type => 
                                `<option value="${type}">${locationTypes[type].label}</option>`
                            ).join('')}
                        </select>
                    </div>
                    <div class="location-input-group">
                        <label for="${locationId}_address">Address</label>
                        <input type="text" id="${locationId}_address" placeholder="Enter address...">
                    </div>
                </div>
                <div class="priority-slider">
                    <label>Priority: <span class="slider-value" id="${locationId}_priority_value">5</span></label>
                    <div class="slider-container">
                        <input type="range" id="${locationId}_priority" min="1" max="10" value="5" class="priority-slider">
                    </div>
                </div>
            `;
            
            dynamicLocationsDiv.appendChild(locationGroup);
            
            // Initialize the slider for this new location
            const slider = document.getElementById(`${locationId}_priority`);
            const valueSpan = document.getElementById(`${locationId}_priority_value`);
            slider.addEventListener('input', function() {
                valueSpan.textContent = this.value;
            });
            
            // Initialize autocomplete for the new address input
            const addressInput = document.getElementById(`${locationId}_address`);
            if (addressInput) {
                initAutocompleteForInput(addressInput);
            }
            
            dynamicLocations.push(locationId);
        }

        // Update dynamic location icon when type changes
        function updateDynamicLocationIcon(locationId) {
            const typeSelect = document.getElementById(`${locationId}_type`);
            const header = document.querySelector(`#${locationId} .dynamic-location-header h4`);
            const selectedType = typeSelect.value;
            
            header.innerHTML = `${locationTypes[selectedType].icon} ${locationTypes[selectedType].label}`;
        }

        // Remove a dynamic location
        function removeDynamicLocation(locationId) {
            const element = document.getElementById(locationId);
            if (element) {
                element.remove();
                dynamicLocations = dynamicLocations.filter(id => id !== locationId);
            }
        }

        // Use example address
        function useExample(address) {
            // Add a new location with the example address
            addDynamicLocation();
            
            // Set the address in the most recently added location
            setTimeout(() => {
                const lastLocationId = dynamicLocations[dynamicLocations.length - 1];
                const addressInput = document.getElementById(`${lastLocationId}_address`);
                if (addressInput) {
                    addressInput.value = address;
                    showStatusMessage(`Added example address: ${address}`, 'success');
                }
            }, 100);
        }

        // Geocode an address to get coordinates
        function geocodeAddress(address) {
            return new Promise((resolve, reject) => {
                geocoder.geocode({ address: address }, function(results, status) {
                    if (status === 'OK' && results[0]) {
                        resolve({
                            lat: results[0].geometry.location.lat(),
                            lng: results[0].geometry.location.lng(),
                            address: results[0].formatted_address
                        });
                    } else {
                        reject(`Geocoding failed for: ${address}. Status: ${status}`);
                    }
                });
            });
        }

        // Calculate distance between two coordinates using Haversine formula
        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Calculate match score for a property
        function calculateMatchScore(property, locations, priorities) {
            let totalScore = 0;
            let maxPossibleScore = 0;
            const distances = {};

            // Calculate scores for each important location
            Object.keys(locations).forEach(locationType => {
                if (locations[locationType] && locations[locationType].length > 0) {
                    // For each location type, calculate the best (minimum) distance
                    let minDistance = Infinity;
                    
                    locations[locationType].forEach(location => {
                        const distance = calculateDistance(
                            property.lat, property.lng,
                            location.lat,
                            location.lng
                        );
                        
                        if (distance < minDistance) {
                            minDistance = distance;
                        }
                    });
                    
                    distances[locationType] = minDistance;
                    
                    // Convert distance to score (closer = higher score)
                    const distanceScore = Math.max(0, 100 - (minDistance * 10)); // 10km = 0 score
                    const priorityWeight = priorities[locationType] / 10;
                    
                    totalScore += distanceScore * priorityWeight;
                    maxPossibleScore += 100 * priorityWeight;
                }
            });

            const finalScore = maxPossibleScore > 0 ? (totalScore / maxPossibleScore) * 100 : 0;
            
            return {
                score: Math.round(finalScore),
                distances: distances
            };
        }

        // Get match category based on score
        function getMatchCategory(score) {
            if (score >= 80) return 'high-match';
            if (score >= 60) return 'medium-match';
            return 'low-match';
        }

        // Create bounded area polygon with proper shading
        function createBoundedArea() {
            // Remove existing bounded area
            if (boundedAreaPolygon) {
                boundedAreaPolygon.setMap(null);
            }
            
            // Get all important location coordinates
            const locationCoords = [];
            Object.values(importantLocations).forEach(locationArray => {
                locationArray.forEach(location => {
                    locationCoords.push({
                        lat: location.lat,
                        lng: location.lng
                    });
                });
            });
            
            if (locationCoords.length < 2) {
                showStatusMessage('Need at least 2 locations to create a bounded area', 'warning');
                return;
            }
            
            // Create a polygon that encompasses all points with a buffer
            boundedAreaBounds = new google.maps.LatLngBounds();
            locationCoords.forEach(coord => boundedAreaBounds.extend(coord));
            
            // Get the bounds coordinates
            const ne = boundedAreaBounds.getNorthEast();
            const sw = boundedAreaBounds.getSouthWest();
            
            // Create a polygon with the bounds
            const polygonCoords = [
                { lat: ne.lat(), lng: sw.lng() }, // Southwest
                { lat: ne.lat(), lng: ne.lng() }, // Northwest
                { lat: sw.lat(), lng: ne.lng() }, // Northeast
                { lat: sw.lat(), lng: sw.lng() }  // Southeast
            ];
            
            // Create polygon with proper shading
            boundedAreaPolygon = new google.maps.Polygon({
                paths: polygonCoords,
                strokeColor: '#FF6B6B',
                strokeOpacity: 0.8,
                strokeWeight: 2,
                fillColor: '#FF6B6B',
                fillOpacity: 0.35, // Increased opacity for better visibility
                map: map
            });
            
            // Fit map to show the bounded area with some padding
            map.fitBounds(boundedAreaBounds);
            
            showStatusMessage('Bounded area created around your important locations', 'success');
        }

        // Check if a property is within the bounded area
        function isPropertyInBoundedArea(property) {
            if (!boundedAreaBounds) return false;
            
            const latCol = findColumn(['Latitude', 'lat', 'latitude']);
            const lngCol = findColumn(['Longitude', 'lng', 'lon', 'longitude']);
            
            if (!latCol || !lngCol) return false;
            
            const lat = parseFloat(property[latCol]);
            const lng = parseFloat(property[lngCol]);
            
            if (!lat || !lng || isNaN(lat) || isNaN(lng)) return false;
            
            const propertyLatLng = new google.maps.LatLng(lat, lng);
            return boundedAreaBounds.contains(propertyLatLng);
        }

        // Toggle bounded area visibility
        function toggleBoundedArea() {
            if (!boundedAreaPolygon) {
                createBoundedArea();
                isBoundedAreaVisible = true;
                document.getElementById('boundedAreaToggleText').textContent = '🗺️ Hide Bounded Area';
            } else {
                boundedAreaPolygon.setMap(isBoundedAreaVisible ? null : map);
                isBoundedAreaVisible = !isBoundedAreaVisible;
                document.getElementById('boundedAreaToggleText').textContent = 
                    isBoundedAreaVisible ? '🗺️ Hide Bounded Area' : '🗺️ Show Bounded Area';
            }
        }

        // Toggle filter to show only properties in bounded area
        function toggleFilterInArea() {
            isFilterInAreaActive = !isFilterInAreaActive;
            const filterBtn = document.getElementById('filterInAreaBtn');
            const filterText = document.getElementById('filterInAreaText');
            
            if (isFilterInAreaActive) {
                if (!boundedAreaBounds) {
                    createBoundedArea();
                }
                
                // Filter properties to show only those within bounded area
                filteredData = matchResults.filter(property => isPropertyInBoundedArea(property));
                filterBtn.classList.add('active');
                filterText.textContent = '📍 Showing Properties in Area';
                showStatusMessage(`Showing ${filteredData.length} properties within the bounded area`, 'success');
            } else {
                // Show all match results
                filteredData = [...matchResults];
                filterBtn.classList.remove('active');
                filterText.textContent = '📍 Show Only Properties in Area';
                showStatusMessage('Showing all matching properties', 'info');
            }
            
            displayResults();
            plotPoints();
            updateStats();
        }

        // Enhanced rent input parser to handle formats like 10k, 100k, 1.5L, etc.
        function parseRentInput(input) {
            if (!input) return 0;
            
            // Convert to string and trim
            input = String(input).trim().toLowerCase();
            
            // Handle different formats
            if (input.includes('l') || input.includes('lakh')) {
                // Handle lakh format (e.g., 1.5L, 2L, 1.5 lakh)
                const numberPart = input.replace(/[^\d.]/g, '');
                const number = parseFloat(numberPart);
                return isNaN(number) ? 0 : number * 100000;
            } else if (input.includes('k') || input.includes('thousand')) {
                // Handle thousand format (e.g., 10k, 15.5k, 10 thousand)
                const numberPart = input.replace(/[^\d.]/g, '');
                const number = parseFloat(numberPart);
                return isNaN(number) ? 0 : number * 1000;
            } else if (input.includes('cr') || input.includes('crore')) {
                // Handle crore format (e.g., 1cr, 1.5cr)
                const numberPart = input.replace(/[^\d.]/g, '');
                const number = parseFloat(numberPart);
                return isNaN(number) ? 0 : number * 10000000;
            } else {
                // Handle regular number format
                const numberPart = input.replace(/[^\d.]/g, '');
                const number = parseFloat(numberPart);
                return isNaN(number) ? 0 : number;
            }
        }

        // Check if a property has a specific amenity (with variations)
        function hasAmenity(rowAmenities, selectedAmenity) {
            if (!rowAmenities || !selectedAmenity) return false;
            
            const variations = amenityVariations[selectedAmenity] || [selectedAmenity];
            
            return variations.some(variation => 
                rowAmenities.toLowerCase().includes(variation.toLowerCase())
            );
        }

        // Apply property filters
        function applyPropertyFilters() {
            const nameFilter = document.getElementById('filter_name').value.toLowerCase();
            const addressFilter = document.getElementById('filter_address').value.toLowerCase();
            const bhkFilter = document.getElementById('filter_bhk').value;
            const parkingFilter = document.getElementById('filter_parking').value;
            const furnishedFilter = document.getElementById('filter_furnished').value;
            const areaFilter = document.getElementById('filter_area').value;
            const rentMinInput = document.getElementById('filter_rent_min').value;
            const rentMaxInput = document.getElementById('filter_rent_max').value;
            const carAreaMinFilter = document.getElementById('filter_carArea_min').value;
            const carAreaMaxFilter = document.getElementById('filter_carArea_max').value;
            
            // Parse rent inputs using the enhanced parser
            const rentMinFilter = parseRentInput(rentMinInput);
            const rentMaxFilter = parseRentInput(rentMaxInput);
            
            // Get selected amenities from both categories
            const selectedApartmentAmenities = Array.from(document.querySelectorAll('#insideApartmentAmenities input[type="checkbox"]:checked'))
                .map(checkbox => checkbox.value);
            const selectedPremisesAmenities = Array.from(document.querySelectorAll('#insidePremisesAmenities input[type="checkbox"]:checked'))
                .map(checkbox => checkbox.value);
            
            const nameCol = findColumn(['Project_Name', 'name', 'title', 'property']);
            const addressCol = findColumn(['Location', 'address', 'location']);
            const bhkCol = findColumn(['BHK', 'bhk']);
            const parkingCol = findColumn(['Parking', 'parking']);
            const furnishedCol = findColumn(['Furnishing', 'furnished', 'furnish']);
            const areaCol = findColumn(['Area', 'area', 'locality']);
            const priceCol = findColumn(['Rent', 'rent', 'price']);
            const amenitiesCol = findColumn(['Amenities', 'amenities', 'amenity']);
            const carAreaCol = findColumn(['Carpet Area', 'carpet area', 'CarArea', 'Carpet_Area']);
            
            console.log('Applying filters...');
            console.log('Rent filter range:', rentMinFilter, 'to', rentMaxFilter);
            
            // If we have match results, filter those. Otherwise, filter all data
            const dataToFilter = matchResults.length > 0 ? matchResults : allData;
            
            filteredData = dataToFilter.filter(row => {
                const nameMatch = !nameFilter || (nameCol && String(row[nameCol] || '').toLowerCase().includes(nameFilter));
                const addressMatch = !addressFilter || (addressCol && String(row[addressCol] || '').toLowerCase().includes(addressFilter));
                
                let bhkMatch = true;
                if (bhkFilter && bhkCol) {
                    const rowBHK = String(row[bhkCol] || '').trim();
                    // Extract numeric value from BHK data
                    const rowBHKNum = rowBHK.match(/(\d+)/);
                    const filterBHKNum = bhkFilter.match(/(\d+)/);
                    
                    if (rowBHKNum && filterBHKNum) {
                        bhkMatch = rowBHKNum[1] === filterBHKNum[1];
                    } else {
                        bhkMatch = rowBHK === bhkFilter || rowBHK.includes(bhkFilter);
                    }
                }
                
                let parkingMatch = true;
                if (parkingFilter && parkingCol) {
                    const totalParking = calculateTotalParking(row[parkingCol]);
                    parkingMatch = totalParking.toString() === parkingFilter;
                }
                
                const furnishedMatch = !furnishedFilter || (furnishedCol && row[furnishedCol] === furnishedFilter);
                const areaMatch = !areaFilter || (areaCol && row[areaCol] === areaFilter);
                
                // Carpet Area filter
                let carAreaMatch = true;
                if (carAreaCol && (carAreaMinFilter || carAreaMaxFilter)) {
                    const carAreaValue = parseCarpetArea(row[carAreaCol]);
                    if (carAreaMinFilter && carAreaValue < parseFloat(carAreaMinFilter)) {
                        carAreaMatch = false;
                    }
                    if (carAreaMaxFilter && carAreaValue > parseFloat(carAreaMaxFilter)) {
                        carAreaMatch = false;
                    }
                }
                
                // Rent filter
                let rentMatch = true;
                if (priceCol && (rentMinFilter || rentMaxFilter)) {
                    const rentValue = parsePrice(row[priceCol]);
                    if (rentMinFilter && rentValue < rentMinFilter) {
                        rentMatch = false;
                    }
                    if (rentMaxFilter && rentValue > rentMaxFilter) {
                        rentMatch = false;
                    }
                }
                
                // Amenities filter with variations
                let apartmentAmenitiesMatch = true;
                let premisesAmenitiesMatch = true;
                
                if ((selectedApartmentAmenities.length > 0 || selectedPremisesAmenities.length > 0) && amenitiesCol) {
                    const rowAmenities = row[amenitiesCol] || '';
                    
                    // Check Inside Apartment amenities
                    if (selectedApartmentAmenities.length > 0) {
                        apartmentAmenitiesMatch = selectedApartmentAmenities.every(selAmenity => 
                            hasAmenity(rowAmenities, selAmenity)
                        );
                    }
                    
                    // Check Inside Premises amenities
                    if (selectedPremisesAmenities.length > 0) {
                        premisesAmenitiesMatch = selectedPremisesAmenities.every(selAmenity => 
                            hasAmenity(rowAmenities, selAmenity)
                        );
                    }
                }
                
                return nameMatch && addressMatch && bhkMatch && parkingMatch && 
                       furnishedMatch && areaMatch && carAreaMatch && rentMatch && 
                       apartmentAmenitiesMatch && premisesAmenitiesMatch;
            });
            
            console.log('Filtered results:', filteredData.length);
            
            displayResults();
            plotPoints();
            updateStats();
            
            showStatusMessage(`Applied filters: ${filteredData.length} properties match your criteria`, 'success');
        }

        // Reset property filters
        function resetPropertyFilters() {
            document.getElementById('filter_name').value = '';
            document.getElementById('filter_address').value = '';
            document.getElementById('filter_bhk').value = '';
            document.getElementById('filter_parking').value = '';
            document.getElementById('filter_furnished').value = '';
            document.getElementById('filter_area').value = '';
            document.getElementById('filter_carArea_min').value = '';
            document.getElementById('filter_carArea_max').value = '';
            document.getElementById('filter_rent_min').value = '';
            document.getElementById('filter_rent_max').value = '';
            
            // Reset amenities checkboxes
            document.querySelectorAll('#insideApartmentAmenities input[type="checkbox"]').forEach(checkbox => {
                checkbox.checked = false;
            });
            document.querySelectorAll('#insidePremisesAmenities input[type="checkbox"]').forEach(checkbox => {
                checkbox.checked = false;
            });
            
            // Reset to original data (either match results or all data)
            filteredData = matchResults.length > 0 ? [...matchResults] : [...allData];
            displayResults();
            plotPoints();
            
            showStatusMessage('All property filters have been reset', 'info');
        }

        // Create amenities checkboxes
        function createAmenitiesCheckboxes() {
            // Create checkboxes for Inside Apartment amenities
            const insideApartmentContainer = document.getElementById('insideApartmentAmenities');
            amenities["Inside Apartment"].forEach(amenity => {
                const checkboxDiv = document.createElement('div');
                checkboxDiv.className = 'amenity-checkbox';
                checkboxDiv.innerHTML = `
                    <input type="checkbox" id="apartment_${amenity.replace(/\s+/g, '_')}" value="${amenity}">
                    <label for="apartment_${amenity.replace(/\s+/g, '_')}">${amenity}</label>
                `;
                insideApartmentContainer.appendChild(checkboxDiv);
            });

            // Create checkboxes for Inside Premises amenities
            const insidePremisesContainer = document.getElementById('insidePremisesAmenities');
            amenities["Inside Premises"].forEach(amenity => {
                const checkboxDiv = document.createElement('div');
                checkboxDiv.className = 'amenity-checkbox';
                checkboxDiv.innerHTML = `
                    <input type="checkbox" id="premises_${amenity.replace(/\s+/g, '_')}" value="${amenity}">
                    <label for="premises_${amenity.replace(/\s+/g, '_')}">${amenity}</label>
                `;
                insidePremisesContainer.appendChild(checkboxDiv);
            });
        }

        // Populate filter dropdowns
        function populateFilters() {
            const filterFields = {
                'bhk': findColumn(['BHK', 'bhk']),
                'parking': findColumn(['Parking', 'parking']),
                'furnished': findColumn(['Furnishing', 'furnished', 'furnish']),
                'area': findColumn(['Area', 'area', 'locality']),
            };
            
            Object.keys(filterFields).forEach(key => {
                const column = filterFields[key];
                console.log(`Populating ${key} filter with column:`, column);
                
                if (column) {
                    const select = document.getElementById(`filter_${key}`);
                    
                    let uniqueValues = [];
                    
                    if (key === 'bhk') {
                        // Special handling for BHK values
                        uniqueValues = [...new Set(allData.map(row => {
                            const value = row[column];
                            if (!value) return null;
                            
                            // Extract numeric BHK values
                            const bhkMatch = String(value).match(/(\d+)\s*BHK?/i) || String(value).match(/(\d+)/);
                            return bhkMatch ? bhkMatch[1] : String(value).trim();
                        }))].filter(v => v !== null && v !== '' && v !== undefined)
                        .sort((a, b) => parseInt(a) - parseInt(b));
                        
                        console.log('BHK unique values:', uniqueValues);
                        
                    } else if (key === 'parking') {
                        const parkingTotals = allData.map(row => {
                            return calculateTotalParking(row[column]);
                        });
                        
                        uniqueValues = [...new Set(parkingTotals)]
                            .filter(v => v !== null && v !== undefined && v !== 0)
                            .sort((a, b) => a - b);
                    } else {
                        uniqueValues = [...new Set(allData.map(row => row[column]))]
                            .filter(v => v !== '' && v !== null && v !== undefined)
                            .sort();
                    }
                    
                    // Clear existing options (keep "All" option)
                    select.innerHTML = '<option value="">All ' + key.charAt(0).toUpperCase() + key.slice(1) + '</option>';
                    
                    uniqueValues.forEach(value => {
                        const option = document.createElement('option');
                        option.value = value;
                        
                        // Format display text for BHK
                        if (key === 'bhk') {
                            option.textContent = value + ' BHK';
                        } else {
                            option.textContent = value;
                        }
                        
                        select.appendChild(option);
                    });
                }
            });
        }

        // Calculate total parking from string
        function calculateTotalParking(parkingStr) {
            if (!parkingStr) return 0;
            
            const numbers = parkingStr.match(/\d+/g);
            if (!numbers) return 0;
            
            return numbers.reduce((total, num) => total + parseInt(num), 0);
        }

        // Parse carpet area
        function parseCarpetArea(areaStr) {
            if (!areaStr) return 0;
            if (typeof areaStr === 'string') {
                // Extract numbers from carpet area string (e.g., "1000 sqft" -> 1000)
                const match = areaStr.match(/(\d+)/);
                return match ? parseInt(match[1]) : 0;
            }
            return parseFloat(areaStr);
        }

        // Main function to find property matches
        async function findPropertyMatches() {
            // Get all dynamic locations - now supports multiple of same type
            const allLocations = {};
            const allPriorities = {};
            
            dynamicLocations.forEach(locationId => {
                const type = document.getElementById(`${locationId}_type`).value;
                const address = document.getElementById(`${locationId}_address`).value;
                const priority = parseInt(document.getElementById(`${locationId}_priority`).value);
                
                if (address) {
                    // Initialize array for this type if it doesn't exist
                    if (!allLocations[type]) {
                        allLocations[type] = [];
                    }
                    // Add address to the array for this type
                    allLocations[type].push(address);
                    
                    // Store priority (use the highest priority if multiple of same type)
                    if (!allPriorities[type] || priority > allPriorities[type]) {
                        allPriorities[type] = priority;
                    }
                }
            });

            // Validate at least one address is set
            if (Object.keys(allLocations).length === 0) {
                showStatusMessage('Please set at least one important location address.', 'error');
                return;
            }

            showStatusMessage('Geocoding addresses and finding matching properties...', 'info');
            showLoading();

            try {
                // Geocode all addresses - now supports multiple locations per type
                importantLocations = {};
                
                for (const [type, addresses] of Object.entries(allLocations)) {
                    importantLocations[type] = [];
                    
                    for (const address of addresses) {
                        const geocodedLocation = await geocodeAddress(address);
                        importantLocations[type].push(geocodedLocation);
                    }
                }

                // Show bounded area controls
                document.getElementById('boundedAreaControls').classList.add('active');

                // Reset area filter when new search is performed
                isFilterInAreaActive = false;
                document.getElementById('filterInAreaBtn').classList.remove('active');
                document.getElementById('filterInAreaText').textContent = '📍 Show Only Properties in Area';

                // Calculate match scores for all properties
                matchResults = allData.map(property => {
                    const latCol = findColumn(['Latitude', 'lat', 'latitude']);
                    const lngCol = findColumn(['Longitude', 'lng', 'lon', 'longitude']);
                    
                    if (!latCol || !lngCol) {
                        return {
                            ...property,
                            matchScore: 0,
                            distances: {},
                            matchCategory: 'low-match'
                        };
                    }
                    
                    const lat = parseFloat(property[latCol]);
                    const lng = parseFloat(property[lngCol]);
                    
                    if (!lat || !lng || isNaN(lat) || isNaN(lng)) {
                        return {
                            ...property,
                            matchScore: 0,
                            distances: {},
                            matchCategory: 'low-match'
                        };
                    }
                    
                    const propertyWithCoords = {
                        ...property,
                        lat: lat,
                        lng: lng
                    };
                    
                    const matchInfo = calculateMatchScore(propertyWithCoords, importantLocations, allPriorities);
                    return {
                        ...property,
                        lat: lat,
                        lng: lng,
                        matchScore: matchInfo.score,
                        distances: matchInfo.distances,
                        matchCategory: getMatchCategory(matchInfo.score)
                    };
                });

                // MODIFIED: Filter out properties with score less than 60% and sort by match score
                matchResults = matchResults
                    .filter(property => property.matchScore >= 60) // Only show 60%+ matches
                    .sort((a, b) => b.matchScore - a.matchScore);

                // Set filteredData to match results for display
                filteredData = matchResults;

                // Display results
                displayResults();
                plotPoints();
                updateMatchSummary();

                // Show match summary
                document.getElementById('matchSummary').classList.add('active');
                
                if (matchResults.length === 0) {
                    showStatusMessage('No properties found with 60% or higher match score.', 'warning');
                } else {
                    showStatusMessage(`Found ${matchResults.length} properties with 60%+ match score!`, 'success');
                }
            } catch (error) {
                showStatusMessage(error, 'error');
            }
        }

        // Update match summary statistics
        function updateMatchSummary() {
            const highMatches = matchResults.filter(p => p.matchCategory === 'high-match').length;
            const mediumMatches = matchResults.filter(p => p.matchCategory === 'medium-match').length;
            const avgScore = matchResults.length > 0 
                ? Math.round(matchResults.reduce((sum, p) => sum + p.matchScore, 0) / matchResults.length)
                : 0;

            document.getElementById('totalProperties').textContent = matchResults.length;
            document.getElementById('highMatches').textContent = highMatches;
            document.getElementById('mediumMatches').textContent = mediumMatches;
            document.getElementById('avgMatchScore').textContent = avgScore + '%';
        }

        // Reset match finder
        function resetMatchFinder() {
            // Clear all dynamic locations
            const dynamicLocationsDiv = document.getElementById('dynamicLocations');
            dynamicLocationsDiv.innerHTML = '';
            dynamicLocations = [];
            
            // Add one default location
            addDynamicLocation();
            
            matchResults = [];
            document.getElementById('matchSummary').classList.remove('active');
            
            // Hide bounded area controls
            document.getElementById('boundedAreaControls').classList.remove('active');
            
            // Remove bounded area
            if (boundedAreaPolygon) {
                boundedAreaPolygon.setMap(null);
                boundedAreaPolygon = null;
            }
            isBoundedAreaVisible = false;
            isFilterInAreaActive = false;
            boundedAreaBounds = null;
            
            // Reset filter button
            document.getElementById('filterInAreaBtn').classList.remove('active');
            document.getElementById('filterInAreaText').textContent = '📍 Show Only Properties in Area';
            
            // Reset to show all data
            filteredData = [...allData];
            displayResults();
            plotPoints();
            
            showStatusMessage('Match finder has been reset.', 'info');
        }

        // Load data from published CSV
        async function loadData() {
            try {
                document.getElementById('stats').innerHTML = '<strong>Loading property data from Google Sheets...</strong>';
                showStatusMessage('Loading data from published Google Sheets CSV...', 'info');
                
                const response = await fetch(SHEETS_CSV_URL);
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch CSV: ${response.status}`);
                }
                
                const csvText = await response.text();
                
                // Parse CSV using Papa Parse
                Papa.parse(csvText, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        if (results.errors.length > 0) {
                            console.warn('CSV parsing warnings:', results.errors);
                        }
                        
                        processCSVData(results.data);
                    },
                    error: function(error) {
                        throw new Error(`CSV parsing error: ${error.message}`);
                    }
                });
                
            } catch (error) {
                console.error('Error loading data:', error);
                showError('Error loading data: ' + error.message);
                showStatusMessage('Error: ' + error.message, 'error');
            }
        }

        // Process CSV data
        function processCSVData(data) {
            if (data.length === 0) {
                showError('No data found in the CSV file');
                return;
            }

            // Get headers from the first row keys
            headers = Object.keys(data[0]);
            
            // Process each row
            allData = data.map((row, index) => {
                const rowData = {};
                headers.forEach(header => {
                    rowData[header] = row[header] || '';
                });
                rowData._id = index;
                rowData._rowNumber = index + 2; // +2 because CSV has header row
                return rowData;
            });
            
            console.log('Available columns from CSV:', headers);
            console.log(`Loaded ${allData.length} properties from CSV`);
            
            // Continue with data processing
            processDataAfterLoad();
        }

        async function processDataAfterLoad() {
            populateFilters();
            createAmenitiesCheckboxes();
            filteredData = [...allData];
            displayResults(); // Display results immediately
            await plotPoints();
            
            showStatusMessage(`Successfully loaded ${allData.length} properties from CSV`, 'success');
        }

        async function plotPoints() {
            // Clear existing markers
            markers.forEach(marker => marker.setMap(null));
            infoWindows.forEach(iw => iw.close());
            markers = [];
            infoWindows = [];
            
            const latCol = findColumn(['Latitude', 'lat', 'latitude']);
            const lngCol = findColumn(['Longitude', 'lng', 'lon', 'longitude']);
            const addressCol = findColumn(['Location', 'address', 'location']);
            const nameCol = findColumn(['Project_Name', 'name', 'title', 'property']);
            const bhkCol = findColumn(['BHK', 'bhk']);
            const priceCol = findColumn(['Rent', 'rent', 'price']);
            const areaCol = findColumn(['Area', 'area', 'locality']);
            
            if (!latCol || !lngCol) {
                console.error('Latitude or Longitude columns not found');
                return;
            }
            
            let validPoints = 0;
            const bounds = new google.maps.LatLngBounds();
            
            // Add markers for important locations (if in match finder mode)
            if (matchResults.length > 0 && Object.keys(importantLocations).length > 0) {
                Object.keys(importantLocations).forEach(type => {
                    if (importantLocations[type] && importantLocations[type].length > 0) {
                        importantLocations[type].forEach((location, index) => {
                            const icon = locationTypes[type]?.icon || '📍';
                            const title = locationTypes[type]?.label || type;
                            
                            const marker = new google.maps.Marker({
                                position: { lat: location.lat, lng: location.lng },
                                map: map,
                                title: `${title} ${index + 1}: ${location.address}`,
                                icon: {
                                    url: `data:image/svg+xml;charset=UTF-8,<svg width="30" height="30" xmlns="http://www.w3.org/2000/svg"><text x="15" y="20" font-size="20" text-anchor="middle">${icon}</text></svg>`,
                                    scaledSize: new google.maps.Size(30, 30),
                                    anchor: new google.maps.Point(15, 15)
                                }
                            });
                            
                            markers.push(marker);
                        });
                    }
                });
            }
            
            for (const row of filteredData) {
                let lat = parseFloat(row[latCol]);
                let lng = parseFloat(row[lngCol]);
                
                if (!lat || !lng || isNaN(lat) || isNaN(lng)) {
                    continue;
                }
                
                const position = { lat, lng };
                const area = row[areaCol];
                const actualRent = parsePrice(row[priceCol]);
                
                // Check if this property has a match score (from Property Match Finder)
                const matchScore = row.matchScore || 0;
                const matchCategory = row.matchCategory || '';
                
                let markerColor = '#667eea';
                let markerText = formatPriceShort(actualRent);
                
                // If in match finder mode, use match score for coloring
                if (matchResults.length > 0 && matchScore > 0) {
                    if (matchScore >= 80) markerColor = '#4ECDC4';
                    else if (matchScore >= 60) markerColor = '#FFD700';
                    else markerColor = '#FF6B6B';
                    
                    markerText = `${matchScore}%`;
                }
                
                const marker = new google.maps.Marker({
                    position: position,
                    map: map,
                    title: `${row[nameCol]} - ${area}`,
                    icon: {
                        url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
                            <svg width="36" height="24" viewBox="0 0 36 24" xmlns="http://www.w3.org/2000/svg">
                                <rect width="36" height="24" rx="5" ry="5" fill="${markerColor}" stroke="white" stroke-width="2"/>
                                <text x="18" y="15" text-anchor="middle" font-size="10" fill="white" font-weight="bold" font-family="Arial">${markerText}</text>
                            </svg>
                        `),
                        scaledSize: new google.maps.Size(36, 24),
                        anchor: new google.maps.Point(18, 12)
                    }
                });
                
                const infoContent = `
                    <div style="min-width: 250px; padding: 10px;">
                        <h3 style="margin: 0 0 8px 0; color: #333;">${row[nameCol] || 'Property'}</h3>
                        ${actualRent ? `
                            <div style="background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%); padding: 10px; border-radius: 8px; margin-bottom: 8px;">
                                <strong>Actual Rent:</strong> ₹${formatPrice(actualRent)}<br>
                                ${matchScore > 0 ? `<br><strong>Match Score:</strong> ${matchScore}%` : ''}
                            </div>
                        ` : ''}
                        ${bhkCol && row[bhkCol] ? `<p style="margin: 5px 0;"><strong>BHK:</strong> ${row[bhkCol]}</p>` : ''}
                        ${areaCol && row[areaCol] ? `<p style="margin: 5px 0;"><strong>Area:</strong> ${row[areaCol]}</p>` : ''}
                        ${addressCol && row[addressCol] ? `<p style="margin: 5px 0;"><strong>Address:</strong> ${row[addressCol]}</p>` : ''}
                        ${matchScore > 0 && row.distances ? `
                            <div style="font-size: 0.9rem; margin-top: 8px;">
                                <strong>Distances:</strong><br>
                                ${Object.keys(row.distances).map(locationType => {
                                    if (row.distances[locationType]) {
                                        const icon = locationTypes[locationType]?.icon || '📍';
                                        const label = locationTypes[locationType]?.label || locationType;
                                        return `${icon} ${label}: ${row.distances[locationType].toFixed(1)} km<br>`;
                                    }
                                    return '';
                                }).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
                
                const infoWindow = new google.maps.InfoWindow({
                    content: infoContent
                });
                
                marker.addListener('click', () => {
                    infoWindows.forEach(iw => iw.close());
                    infoWindow.open(map, marker);
                });
                
                markers.push(marker);
                infoWindows.push(infoWindow);
                bounds.extend(position);
                validPoints++;
            }
            
            if (markers.length > 0) {
                map.fitBounds(bounds);
            }
            
            updateStats(filteredData.length, validPoints);
        }
        
        function parsePrice(price) {
            if (!price) return 0;
            if (typeof price === 'string') {
                return parseFloat(price.replace(/[^0-9.]/g, ''));
            }
            return parseFloat(price);
        }
        
        function formatPrice(price) {
            return Math.round(parsePrice(price)).toLocaleString('en-IN');
        }
        
        function formatPriceShort(price) {
            price = parsePrice(price);
            if (price >= 100000) {
                return (price / 100000).toFixed(1) + 'L';
            } else if (price >= 1000) {
                return (price / 1000).toFixed(0) + 'K';
            }
            return price.toString();
        }

        function displayResults() {
            const resultsDiv = document.getElementById('results');
            
            if (filteredData.length === 0) {
                let message = 'No properties found';
                if (isFilterInAreaActive) {
                    message = 'No properties found within the bounded area';
                }
                resultsDiv.innerHTML = `<div style="text-align: center; padding: 40px; color: #666;">${message}</div>`;
                return;
            }
            
            const nameCol = findColumn(['Project_Name', 'name', 'title', 'property']);
            const addressCol = findColumn(['Location', 'address', 'location']);
            const priceCol = findColumn(['Rent', 'rent', 'price']);
            const areaCol = findColumn(['Area', 'area', 'locality']);
            const bhkCol = findColumn(['BHK', 'bhk']);
            const furnishedCol = findColumn(['Furnishing', 'furnished', 'furnish']);
            const parkingCol = findColumn(['Parking', 'parking']);
            const amenitiesCol = findColumn(['Amenities', 'amenities', 'amenity']);
            const carAreaCol = findColumn(['Carpet Area', 'carpet area', 'CarArea', 'Carpet_Area']);
            
            const html = filteredData.map((row, index) => {
                const area = row[areaCol];
                const rent = parsePrice(row[priceCol]);
                const totalParking = calculateTotalParking(row[parkingCol]);
                const matchScore = row.matchScore || 0;
                const matchCategory = row.matchCategory || '';
                
                // Clean up the name and address
                const rawName = nameCol && row[nameCol] ? row[nameCol].trim() : '';
                const rawAddress = addressCol && row[addressCol] ? row[addressCol].trim() : '';

                // Treat "Not Specified" or "NA" or "N/A" as missing
                const isInvalidName = !rawName || 
                                      rawName.toLowerCase() === 'not specified' || 
                                      rawName.toLowerCase() === 'na' || 
                                      rawName.toLowerCase() === 'n/a';

                // Use Location (address) when Project_Name is not specified
                const displayName = !isInvalidName ? rawName : (rawAddress || 'Property');
                
                // Check if this is a top listing (only when highlighted)
                const isTopListing = topListingsHighlighted && index < getTopListingsCount();
                
                let amenitiesHTML = '';
                if (amenitiesCol && row[amenitiesCol]) {
                    const amenitiesList = parseAmenities(row[amenitiesCol]);
                    // Show first 5 amenities
                    amenitiesHTML = `
                        <div class="property-amenities">
                            ${amenitiesList.slice(0, 5).map(a => `<span class="amenity-tag-small">${a}</span>`).join('')}
                            ${amenitiesList.length > 5 ? `<span class="amenity-tag-small">+${amenitiesList.length - 5} more</span>` : ''}
                        </div>
                    `;
                }
                
                // Add proximity information if available (from match finder)
                let proximityHTML = '';
                if (matchScore > 0 && row.distances) {
                    const locationItems = Object.keys(row.distances || {}).map(locationType => {
                        if (row.distances[locationType]) {
                            const icon = locationTypes[locationType]?.icon || '📍';
                            return `
                                <div class="proximity-item">
                                    <span>${icon} ${locationTypes[locationType]?.label || locationType}:</span>
                                    <span class="proximity-distance">${row.distances[locationType].toFixed(1)} km</span>
                                </div>
                            `;
                        }
                        return '';
                    }).join('');
                    
                    proximityHTML = `
                        <div class="property-proximity">
                            ${locationItems}
                        </div>
                    `;
                }
                
                return `
                    <div class="property-card ${matchCategory} ${isTopListing ? 'top-listing' : ''}" style="border-left-color: #667eea">
                        ${matchScore > 0 ? `<span class="match-score">${matchScore}% Match</span>` : ''}
                        <div class='property-name1'>
                        <div class="property-name">${displayName}</div>
                        <div class="property-rent">₹${formatPrice(rent)}/month</div>
                        </div>
                        <div class="property-details">
                            ${bhkCol && row[bhkCol] ? `<span class="detail-tag">${row[bhkCol]} BHK</span>` : ''}
                            ${carAreaCol && row[carAreaCol] ? `<span class="detail-tag">${row[carAreaCol]}</span>` : ''}
                            ${areaCol && row[areaCol] ? `<span class="detail-tag">${area}</span>` : ''}
                            ${furnishedCol && row[furnishedCol] ? `<span class="detail-tag">${row[furnishedCol]}</span>` : ''}
                            ${totalParking > 0 ? `<span class="detail-tag">${totalParking} Parking</span>` : ''}
                        </div>
                        ${amenitiesHTML}
                        ${proximityHTML}
                    </div>
                `;
            }).join('');
            
            resultsDiv.innerHTML = html;
        }
        
        function updateStats(total, visible) {
            const statsDiv = document.getElementById('stats');
            
            if (matchResults.length > 0) {
                let areaText = '';
                if (isFilterInAreaActive) {
                    areaText = ' (within bounded area)';
                }
                
                let topListingsText = '';
                if (topListingsHighlighted) {
                    topListingsText = ` | ⭐ Top ${getTopListingsCount()} highlighted`;
                }
                
                statsDiv.innerHTML = `
                    <strong>Showing ${visible} properties with 60%+ match score${areaText}${topListingsText}</strong><br>
                    <small>Based on proximity to your important locations</small>
                `;
            } else {
                statsDiv.innerHTML = `
                    <strong>Showing ${visible} of ${total} properties</strong><br>
                    <small>Enter your important locations to find matching properties</small>
                `;
            }
        }
        
        function parseAmenities(amenitiesStr) {
            if (!amenitiesStr) return [];
            amenitiesStr = amenitiesStr.replace(/[\[\]']/g, '');
            return amenitiesStr.split(',').map(a => a.trim()).filter(a => a.length > 0);
        }
        
        function showError(message) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = `<div class="error">${message}</div>`;
        }

        function showStatusMessage(message, type = 'info') {
            const statusDiv = document.getElementById('statusMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'status-message';
            
            if (type === 'error') {
                messageDiv.style.background = '#ffe6e6';
                messageDiv.style.color = '#d63031';
                messageDiv.style.borderLeftColor = '#d63031';
            } else if (type === 'success') {
                messageDiv.style.background = '#e6f7e6';
                messageDiv.style.color = '#27ae60';
                messageDiv.style.borderLeftColor = '#27ae60';
            } else if (type === 'warning') {
                messageDiv.style.background = '#fff8e6';
                messageDiv.style.color = '#f39c12';
                messageDiv.style.borderLeftColor = '#f39c12';
            }
            
            messageDiv.textContent = message;
            statusDiv.appendChild(messageDiv);
            
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.parentNode.removeChild(messageDiv);
                }
            }, 5000);
        }

        // Show loading indicator for match finder
        function showLoading() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = `
                <div class="loading">
                    <div style="border: 4px solid #f3f3f3; border-top: 4px solid #667eea; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 0 auto 15px;"></div>
                    <p>Analyzing properties based on your location preferences...</p>
                </div>
            `;
        }

        // Refresh Data Function
        async function refreshData() {
            const refreshBtn = document.getElementById('refreshBtn');
            refreshBtn.textContent = 'Refreshing...';
            refreshBtn.disabled = true;
            
            try {
                // Clear current data
                allData = [];
                filteredData = [];
                clearStatusMessages();
                
                // Reload everything
                await loadData();
                
                refreshBtn.textContent = '✅ Data Refreshed';
                setTimeout(() => {
                    refreshBtn.textContent = '🔄 Refresh Data';
                }, 2000);
                
            } catch (error) {
                showError('Error refreshing data: ' + error.message);
                showStatusMessage('Error refreshing data: ' + error.message, 'error');
                refreshBtn.textContent = '🔄 Refresh Data';
            } finally {
                refreshBtn.disabled = false;
            }
        }

        function clearStatusMessages() {
            document.getElementById('statusMessages').innerHTML = '';
        }
        
        // Get the selected number of top listings to show
        function getTopListingsCount() {
            const select = document.getElementById('topListingsCount');
            return parseInt(select.value);
        }
        
        // Highlight top listings based on match score
        function highlightTopListings() {
            if (matchResults.length === 0) {
                showStatusMessage('Please run "Find Matching Properties" first to see top listings.', 'warning');
                return;
            }
            
            const topCount = getTopListingsCount();
            topListingsHighlighted = true;
            
            // Update display to show top listings with special styling
            displayResults();
            
            // Also update markers on map to highlight top listings
            highlightTopListingsOnMap();
            
            showStatusMessage(`Highlighted top ${topCount} properties with highest match scores`, 'success');
        }
        
        // Clear top listings highlight
        function clearTopListingsHighlight() {
            topListingsHighlighted = false;
            
            // Update display to remove top listing styling
            displayResults();
            
            // Also clear special markers on map
            clearTopListingsMarkers();
            
            showStatusMessage('Cleared top listings highlight', 'info');
        }
        
        // Highlight top listings on the map with special markers
        function highlightTopListingsOnMap() {
            // Clear existing top listing markers
            clearTopListingsMarkers();
            
            const topCount = getTopListingsCount();
            const latCol = findColumn(['Latitude', 'lat', 'latitude']);
            const lngCol = findColumn(['Longitude', 'lng', 'lon', 'longitude']);
            const nameCol = findColumn(['Project_Name', 'name', 'title', 'property']);
            
            if (!latCol || !lngCol) return;
            
            // Get top N properties
            const topProperties = matchResults.slice(0, topCount);
            
            // Create special markers for top listings
            topProperties.forEach((property, index) => {
                const lat = parseFloat(property[latCol]);
                const lng = parseFloat(property[lngCol]);
                
                if (!lat || !lng || isNaN(lat) || isNaN(lng)) return;
                
                const position = { lat, lng };
                
                // Create a special marker for top listings
                const topMarker = new google.maps.Marker({
                    position: position,
                    map: map,
                    title: `⭐ Top ${index + 1}: ${property[nameCol] || 'Property'}`,
                    icon: {
                        url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
                            <svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="20" cy="20" r="18" fill="#FFD700" stroke="#FFA500" stroke-width="2"/>
                                <text x="20" y="26" text-anchor="middle" font-size="14" fill="#333" font-weight="bold">${index + 1}</text>
                            </svg>
                        `),
                        scaledSize: new google.maps.Size(40, 40),
                        anchor: new google.maps.Point(20, 20)
                    },
                    zIndex: 1000 // Ensure top markers appear above regular markers
                });
                
                const infoContent = `
                    <div style="min-width: 250px; padding: 10px;">
                        <h3 style="margin: 0 0 8px 0; color: #333;">
                            ⭐ Top ${index + 1}: ${property[nameCol] || 'Property'}
                        </h3>
                        <div style="background: linear-gradient(135deg, #FFD70015 0%, #FFA50015 100%); padding: 10px; border-radius: 8px; margin-bottom: 8px;">
                            <strong>Match Score:</strong> ${property.matchScore}%<br>
                            <strong>Rank:</strong> ${index + 1} of ${matchResults.length}
                        </div>
                        ${property.distances ? `
                            <div style="font-size: 0.9rem; margin-top: 8px;">
                                <strong>Distances:</strong><br>
                                ${Object.keys(property.distances).map(locationType => {
                                    if (property.distances[locationType]) {
                                        const icon = locationTypes[locationType]?.icon || '📍';
                                        const label = locationTypes[locationType]?.label || locationType;
                                        return `${icon} ${label}: ${property.distances[locationType].toFixed(1)} km<br>`;
                                    }
                                    return '';
                                }).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
                
                const infoWindow = new google.maps.InfoWindow({
                    content: infoContent
                });
                
                topMarker.addListener('click', () => {
                    infoWindows.forEach(iw => iw.close());
                    infoWindow.open(map, topMarker);
                });
                
                topListingsMarkers.push({
                    marker: topMarker,
                    infoWindow: infoWindow
                });
            });
            
            // If there are top listings, adjust map view to show them
            if (topProperties.length > 0) {
                const bounds = new google.maps.LatLngBounds();
                topProperties.forEach(property => {
                    const lat = parseFloat(property[latCol]);
                    const lng = parseFloat(property[lngCol]);
                    if (lat && lng && !isNaN(lat) && !isNaN(lng)) {
                        bounds.extend({ lat, lng });
                    }
                });
                
                if (!bounds.isEmpty()) {
                    map.fitBounds(bounds);
                }
            }
        }
        
        // Clear top listings markers from map
        function clearTopListingsMarkers() {
            topListingsMarkers.forEach(item => {
                item.marker.setMap(null);
                item.infoWindow.close();
            });
            topListingsMarkers = [];
        }
        
        // Error handling for Google Maps API
        window.gm_authFailure = function() {
            showStatusMessage('Google Maps authentication failed. Please check your API key.', 'error');
        };
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBBcaIOoP7kpoXy1sDs2MHX1yj92bzBbGo&callback=initMap&libraries=places,geometry"></script>
</body>
</html>