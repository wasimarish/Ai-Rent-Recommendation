<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Property Match Finder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #666;
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
            width: 100%;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2.2rem;
            margin-bottom: 8px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 0.9rem;
        }

        /* Property Match Finder Section */
        .match-finder-section {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            border-left: 4px solid #FF6B6B;
        }

        .match-finder-section h3 {
            margin-bottom: 20px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.3rem;
        }

        .important-locations {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .location-group {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            padding: 20px;
            border: 2px solid #e0e0e0;
            transition: all 0.3s ease;
        }

        .location-group:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }

        .location-group h4 {
            margin-bottom: 15px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1.1rem;
        }

        .location-input-group {
            margin-bottom: 12px;
            position: relative;
        }

        .location-input-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
            color: #555;
            font-size: 0.9rem;
        }

        .location-input-group input, .location-input-group select {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .location-input-group input:focus, .location-input-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .priority-slider {
            margin-top: 15px;
        }

        .priority-slider label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
            font-size: 0.9rem;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider-value {
            min-width: 40px;
            text-align: center;
            font-weight: bold;
            color: #667eea;
        }

        input[type="range"] {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: #e0e0e0;
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
        }

        /* Dynamic Location Groups */
        .dynamic-locations {
            margin-bottom: 20px;
        }

        .dynamic-location-group {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            padding: 15px;
            border: 2px solid #e0e0e0;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .dynamic-location-group:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }

        .dynamic-location-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .dynamic-location-header h4 {
            color: #333;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1.1rem;
        }

        .remove-location {
            background: #FF6B6B;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 12px;
        }

        .dynamic-location-content {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 15px;
        }

        .add-location-btn {
            background: linear-gradient(45deg, #4ECDC4, #44A08D);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 10px 20px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 0 auto;
            transition: all 0.3s ease;
        }

        .add-location-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.4);
        }

        .match-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
            flex-wrap: wrap;
        }

        .match-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .match-btn.primary {
            background: linear-gradient(45deg, #FF6B6B, #FF8E53);
            color: white;
        }

        .match-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }

        .match-btn.secondary {
            background: #f8f9fa;
            color: #333;
            border: 2px solid #e0e0e0;
        }

        .match-btn.secondary:hover {
            background: #e9ecef;
        }

        .content-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: 600px;
        }

        .results-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px;
            overflow-y: auto;
            height: 600px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .map-container {
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            position: relative;
        }

        #map {
            height: 100%;
            width: 100%;
        }

        .property-card {
            background: white;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            cursor: pointer;
            border-left: 4px solid #667eea;
            position: relative;
        }
        
        .property-card.high-match {
            border-left: 4px solid #4ECDC4;
            background: linear-gradient(45deg, #f0fff0, #e6ffe6);
        }

        .property-card.medium-match {
            border-left: 4px solid #FFD700;
            background: linear-gradient(45deg, #fffaf0, #fff5e6);
        }

        .property-card.low-match {
            border-left: 4px solid #FF6B6B;
            background: linear-gradient(45deg, #fff0f0, #ffe6e6);
        }

        .property-name1{
            display:flex;
            justify-content: space-between;
        }

        .property-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        .property-name {
            font-size: 1.1rem;
            font-weight: bold;
            color: #333;
            margin-bottom: 6px;
        }

        .property-rent {
            font-size: 1rem;
            color: #667eea;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .property-details {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            margin-bottom: 8px;
        }

        .detail-tag {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 3px 6px;
            border-radius: 10px;
            font-size: 0.75rem;
            white-space: nowrap;
        }

        .property-amenities {
            display: flex;
            gap: 3px;
            margin-top: 6px;
            flex-wrap: wrap;
        }

        .amenity-tag-small {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.5rem;
            text-align: center;
        }

        .stats {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 12px;
            border-radius: 12px;
            margin-bottom: 15px;
            text-align: center;
        }

        .loading {
            text-align: center;
            padding: 15px;
            color: #667eea;
            font-weight: bold;
        }

        .error {
            background: #ffe6e6;
            color: #d63031;
            padding: 8px;
            border-radius: 8px;
            margin: 8px 0;
        }

        .status-message {
            background: #e3f2fd;
            color: #1976d2;
            padding: 8px 12px;
            border-radius: 8px;
            margin: 8px 0;
            border-left: 4px solid #1976d2;
            font-size: 0.9rem;
        }

        /* Match Score Indicator */
        .match-score {
            display: inline-block;
            background: linear-gradient(45deg, #4ECDC4, #44A08D);
            color: white;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-left: 10px;
        }

        .property-card .match-score {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 0.7rem;
        }

        /* Match Results Summary */
        .match-summary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            display: none;
        }

        .match-summary.active {
            display: block;
        }

        .match-summary h4 {
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .match-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .stat-item {
            text-align: center;
            padding: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.8rem;
            opacity: 0.9;
        }

        /* Property proximity info */
        .property-proximity {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #eee;
        }

        .proximity-item {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            margin-bottom: 4px;
            color: #666;
        }

        .proximity-distance {
            font-weight: bold;
            color: #667eea;
        }

        /* Address examples */
        .address-examples {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #4ECDC4;
        }

        .address-examples h5 {
            margin-bottom: 10px;
            color: #333;
        }

        .example-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }

        .example-item {
            font-size: 0.85rem;
            color: #666;
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            transition: background 0.3s;
        }

        .example-item:hover {
            background: #e9ecef;
        }

        /* Autocomplete dropdown styling */
        .pac-container {
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border: none;
            margin-top: 5px;
        }

        .pac-item {
            padding: 8px 12px;
            border-bottom: 1px solid #f0f0f0;
            font-size: 14px;
        }

        .pac-item:hover {
            background-color: #f5f5f5;
        }

        .pac-item-selected {
            background-color: #e3f2fd;
        }

        .pac-icon {
            margin-top: 5px;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .content-area {
                grid-template-columns: 1fr;
                height: auto;
                gap: 12px;
            }

            /* Make map smaller on top */
            .map-container {
                height: 40vh;
                order: 1;
            }

            /* Make cards fill remaining space */
            .results-panel {
                height: 50vh;
                max-height: none;
                overflow-y: auto;
                order: 2;
            }

            .property-card {
                margin-bottom: 10px;
                padding: 12px;
            }

            .property-name {
                font-size: 1rem;
            }

            .property-rent {
                font-size: 0.9rem;
            }

            .property-details {
                gap: 2px;
            }

            .detail-tag {
                font-size: 0.65rem;
                padding: 2px 5px;
            }

            .amenity-tag-small {
                font-size: 0.6rem;
                padding: 2px 5px;
            }

            .dynamic-location-content {
                grid-template-columns: 1fr;
            }
            
            .important-locations {
                grid-template-columns: 1fr;
            }
            
            .match-actions {
                flex-direction: column;
            }
            
            .match-btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div>
                <h1>🏠 Property Match Finder</h1>
                <p>Find your perfect home based on proximity to important locations</p>
            </div>
        </div>

        <!-- Property Match Finder Section -->
        <div class="match-finder-section">
            <h3>🎯 Set Your Important Locations</h3>
            
            <div class="important-locations">
                <div class="location-group">
                    <h4>🏢 Office Location</h4>
                    <div class="location-input-group">
                        <label for="office_address">Office Address</label>
                        <input type="text" id="office_address" placeholder="e.g., Bandra Kurla Complex, Mumbai">
                    </div>
                    <div class="priority-slider">
                        <label>Commute Priority: <span class="slider-value" id="office_priority_value">5</span></label>
                        <div class="slider-container">
                            <input type="range" id="office_priority" min="1" max="10" value="5" class="priority-slider">
                        </div>
                    </div>
                </div>

                <div class="location-group">
                    <h4>🏫 Child's School</h4>
                    <div class="location-input-group">
                        <label for="school_address">School Address</label>
                        <input type="text" id="school_address" placeholder="e.g., Dhirubhai Ambani International School, Mumbai">
                    </div>
                    <div class="priority-slider">
                        <label>School Priority: <span class="slider-value" id="school_priority_value">8</span></label>
                        <div class="slider-container">
                            <input type="range" id="school_priority" min="1" max="10" value="8" class="priority-slider">
                        </div>
                    </div>
                </div>

                <div class="location-group">
                    <h4>🏥 Hospital/Clinic</h4>
                    <div class="location-input-group">
                        <label for="hospital_address">Hospital Address</label>
                        <input type="text" id="hospital_address" placeholder="e.g., Lilavati Hospital, Mumbai">
                    </div>
                    <div class="priority-slider">
                        <label>Hospital Priority: <span class="slider-value" id="hospital_priority_value">6</span></label>
                        <div class="slider-container">
                            <input type="range" id="hospital_priority" min="1" max="10" value="6" class="priority-slider">
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Dynamic Location Groups -->
            <div class="dynamic-locations" id="dynamicLocations">
                <!-- Dynamic location groups will be added here -->
            </div>
            
            <button class="add-location-btn" onclick="addDynamicLocation()">
                ➕ Add Another Location
            </button>

            <div class="address-examples">
                <h5>💡 Example Addresses (Click to use):</h5>
                <div class="example-list">
                    <div class="example-item" onclick="useExample('office', 'Bandra Kurla Complex, Mumbai')">Bandra Kurla Complex, Mumbai</div>
                    <div class="example-item" onclick="useExample('office', 'Nariman Point, Mumbai')">Nariman Point, Mumbai</div>
                    <div class="example-item" onclick="useExample('school', 'Dhirubhai Ambani International School, Mumbai')">Dhirubhai Ambani School</div>
                    <div class="example-item" onclick="useExample('school', 'Jamnabai Narsee School, Juhu')">Jamnabai Narsee School</div>
                    <div class="example-item" onclick="useExample('hospital', 'Lilavati Hospital, Bandra')">Lilavati Hospital, Bandra</div>
                    <div class="example-item" onclick="useExample('hospital', 'Kokilaben Hospital, Andheri')">Kokilaben Hospital</div>
                </div>
            </div>

            <div class="match-actions">
                <button class="match-btn primary" onclick="findPropertyMatches()">
                    🔍 Find Matching Properties
                </button>
                <button class="match-btn secondary" onclick="useCurrentLocationForOffice()">
                    📍 Use My Location for Office
                </button>
                <button class="match-btn secondary" onclick="resetMatchFinder()">
                    🔄 Reset
                </button>
            </div>
        </div>

        <!-- Match Results Summary -->
        <div class="match-summary" id="matchSummary">
            <h4>📊 Property Match Results</h4>
            <div class="match-stats">
                <div class="stat-item">
                    <div class="stat-value" id="totalProperties">0</div>
                    <div class="stat-label">Total Properties</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="highMatches">0</div>
                    <div class="stat-label">High Matches</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="mediumMatches">0</div>
                    <div class="stat-label">Medium Matches</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="avgMatchScore">0%</div>
                    <div class="stat-label">Avg Match Score</div>
                </div>
            </div>
        </div>

        <!-- Content Area -->
        <div class="content-area">
            <div class="results-panel">
                <div class="stats" id="stats">
                    <strong>Enter your important locations to find matching properties</strong>
                </div>
                <div id="statusMessages"></div>
                <div id="results"></div>
            </div>
            <div class="map-container">
                <div id="map"></div>
            </div>
        </div>
    </div>

    <script>
        // Your published Google Sheets CSV URL
        const SHEETS_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTMjpsUGc_KrCMECutLvsLTLva3BOaOX8H4bvvE8XA7qRltqJjY3Y7_zgvwr2MsKIjCJquXHg6UsErg/pub?output=csv';
        
        // Location types and their icons
        const locationTypes = {
            'office': { icon: '🏢', label: 'Office' },
            'school': { icon: '🏫', label: 'School' },
            'hospital': { icon: '🏥', label: 'Hospital' },
            'gym': { icon: '💪', label: 'Gym/Fitness Center' },
            'temple': { icon: '🛕', label: 'Temple' },
            'mosque': { icon: '🕌', label: 'Mosque' },
            'market': { icon: '🛒', label: 'Market/Shopping' },
            'park': { icon: '🌳', label: 'Park/Recreation' },
            'restaurant': { icon: '🍽️', label: 'Restaurant/Food' },
            'transport': { icon: '🚇', label: 'Transport Hub' },
            'other': { icon: '📍', label: 'Other Important Location' }
        };

        let map;
        let markers = [];
        let allData = [];
        let filteredData = [];
        let headers = [];
        let infoWindows = [];
        let geocoder;
        let autocomplete;
        
        // Property Match Finder variables
        let matchResults = [];
        let importantLocations = {
            office: null,
            school: null,
            hospital: null
        };
        let dynamicLocations = []; // For storing dynamic location inputs

        function findColumn(possibleNames) {
            for (let name of possibleNames) {
                const exactMatch = headers.find(h => h && h.toLowerCase() === name.toLowerCase());
                if (exactMatch) return exactMatch;
                
                const containsMatch = headers.find(h => h && h.toLowerCase().includes(name.toLowerCase()));
                if (containsMatch) return containsMatch;
            }
            return null;
        }
        
        function initMap() {
            showStatusMessage('Google Maps loaded successfully!', 'success');
            map = new google.maps.Map(document.getElementById('map'), {
                center: { lat: 19.0760, lng: 72.8777 }, // Mumbai coordinates
                zoom: 12,
                styles: [
                    {
                        featureType: "poi",
                        elementType: "labels",
                        stylers: [{ visibility: "off" }]
                    }
                ]
            });
            
            geocoder = new google.maps.Geocoder();
            
            // Initialize priority sliders
            initializePrioritySliders();
            
            // Initialize autocomplete for address inputs
            initAutocomplete();
            
            loadData();
        }

        // Initialize Google Places Autocomplete for address inputs
        function initAutocomplete() {
            // Initialize autocomplete for fixed address inputs
            const officeInput = document.getElementById('office_address');
            const schoolInput = document.getElementById('school_address');
            const hospitalInput = document.getElementById('hospital_address');
            
            if (officeInput) {
                const officeAutocomplete = new google.maps.places.Autocomplete(officeInput, {
                    types: ['geocode'],
                    componentRestrictions: { country: 'in' }
                });
                officeAutocomplete.addListener('place_changed', function() {
                    const place = officeAutocomplete.getPlace();
                    if (place.geometry) {
                        showStatusMessage(`Office location set to: ${place.formatted_address}`, 'success');
                    }
                });
            }
            
            if (schoolInput) {
                const schoolAutocomplete = new google.maps.places.Autocomplete(schoolInput, {
                    types: ['school', 'university'],
                    componentRestrictions: { country: 'in' }
                });
                schoolAutocomplete.addListener('place_changed', function() {
                    const place = schoolAutocomplete.getPlace();
                    if (place.geometry) {
                        showStatusMessage(`School location set to: ${place.formatted_address}`, 'success');
                    }
                });
            }
            
            if (hospitalInput) {
                const hospitalAutocomplete = new google.maps.places.Autocomplete(hospitalInput, {
                    types: ['hospital', 'health'],
                    componentRestrictions: { country: 'in' }
                });
                hospitalAutocomplete.addListener('place_changed', function() {
                    const place = hospitalAutocomplete.getPlace();
                    if (place.geometry) {
                        showStatusMessage(`Hospital location set to: ${place.formatted_address}`, 'success');
                    }
                });
            }
            
            // Initialize autocomplete for any existing dynamic location inputs
            dynamicLocations.forEach(locationId => {
                const addressInput = document.getElementById(`${locationId}_address`);
                if (addressInput) {
                    initAutocompleteForInput(addressInput);
                }
            });
        }

        // Initialize autocomplete for a specific input element
        function initAutocompleteForInput(inputElement) {
            const autocomplete = new google.maps.places.Autocomplete(inputElement, {
                types: ['geocode'],
                componentRestrictions: { country: 'in' }
            });
            
            autocomplete.addListener('place_changed', function() {
                const place = autocomplete.getPlace();
                if (place.geometry) {
                    showStatusMessage(`Location set to: ${place.formatted_address}`, 'success');
                }
            });
            
            return autocomplete;
        }

        // Initialize priority sliders for Property Match Finder
        function initializePrioritySliders() {
            const sliders = document.querySelectorAll('.priority-slider');
            sliders.forEach(slider => {
                const valueSpan = slider.parentElement.querySelector('.slider-value');
                slider.addEventListener('input', function() {
                    valueSpan.textContent = this.value;
                });
            });
        }

        // Add a dynamic location input group
        function addDynamicLocation() {
            const dynamicLocationsDiv = document.getElementById('dynamicLocations');
            const locationId = 'dynamic_' + Date.now();
            
            const locationGroup = document.createElement('div');
            locationGroup.className = 'dynamic-location-group';
            locationGroup.id = locationId;
            
            locationGroup.innerHTML = `
                <div class="dynamic-location-header">
                    <h4>📍 Additional Location</h4>
                    <button class="remove-location" onclick="removeDynamicLocation('${locationId}')">Remove</button>
                </div>
                <div class="dynamic-location-content">
                    <div class="location-input-group">
                        <label for="${locationId}_type">Location Type</label>
                        <select id="${locationId}_type" onchange="updateDynamicLocationIcon('${locationId}')">
                            ${Object.keys(locationTypes).map(type => 
                                `<option value="${type}">${locationTypes[type].label}</option>`
                            ).join('')}
                        </select>
                    </div>
                    <div class="location-input-group">
                        <label for="${locationId}_address">Address</label>
                        <input type="text" id="${locationId}_address" placeholder="Enter address...">
                    </div>
                </div>
                <div class="priority-slider">
                    <label>Priority: <span class="slider-value" id="${locationId}_priority_value">5</span></label>
                    <div class="slider-container">
                        <input type="range" id="${locationId}_priority" min="1" max="10" value="5" class="priority-slider">
                    </div>
                </div>
            `;
            
            dynamicLocationsDiv.appendChild(locationGroup);
            
            // Initialize the slider for this new location
            const slider = document.getElementById(`${locationId}_priority`);
            const valueSpan = document.getElementById(`${locationId}_priority_value`);
            slider.addEventListener('input', function() {
                valueSpan.textContent = this.value;
            });
            
            // Initialize autocomplete for the new address input
            const addressInput = document.getElementById(`${locationId}_address`);
            if (addressInput) {
                initAutocompleteForInput(addressInput);
            }
            
            dynamicLocations.push(locationId);
        }

        // Update dynamic location icon when type changes
        function updateDynamicLocationIcon(locationId) {
            const typeSelect = document.getElementById(`${locationId}_type`);
            const header = document.querySelector(`#${locationId} .dynamic-location-header h4`);
            const selectedType = typeSelect.value;
            
            header.innerHTML = `${locationTypes[selectedType].icon} ${locationTypes[selectedType].label}`;
        }

        // Remove a dynamic location
        function removeDynamicLocation(locationId) {
            const element = document.getElementById(locationId);
            if (element) {
                element.remove();
                dynamicLocations = dynamicLocations.filter(id => id !== locationId);
            }
        }

        // Use example address
        function useExample(type, address) {
            document.getElementById(`${type}_address`).value = address;
            showStatusMessage(`Added example ${type} address: ${address}`, 'success');
        }

        // Use current location for office
        function useCurrentLocationForOffice() {
            if (!navigator.geolocation) {
                showStatusMessage('Geolocation is not supported by this browser.', 'error');
                return;
            }

            showStatusMessage('Getting your current location...', 'info');

            navigator.geolocation.getCurrentPosition(
                function(position) {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    
                    // Reverse geocode to get address
                    geocoder.geocode({ location: { lat, lng } }, function(results, status) {
                        if (status === 'OK' && results[0]) {
                            document.getElementById('office_address').value = results[0].formatted_address;
                            showStatusMessage('Office location set to your current address!', 'success');
                        } else {
                            showStatusMessage('Could not find address for your location.', 'error');
                        }
                    });
                },
                function(error) {
                    let errorMessage = 'Unable to get your location. ';
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            errorMessage += 'Please allow location access.';
                            break;
                        case error.POSITION_UNAVAILABLE:
                            errorMessage += 'Location information is unavailable.';
                            break;
                        case error.TIMEOUT:
                            errorMessage += 'Location request timed out.';
                            break;
                        default:
                            errorMessage += 'An unknown error occurred.';
                    }
                    showStatusMessage(errorMessage, 'error');
                }
            );
        }

        // Geocode an address to get coordinates
        function geocodeAddress(address) {
            return new Promise((resolve, reject) => {
                geocoder.geocode({ address: address }, function(results, status) {
                    if (status === 'OK' && results[0]) {
                        resolve({
                            lat: results[0].geometry.location.lat(),
                            lng: results[0].geometry.location.lng(),
                            address: results[0].formatted_address
                        });
                    } else {
                        reject(`Geocoding failed for: ${address}. Status: ${status}`);
                    }
                });
            });
        }

        // Calculate distance between two coordinates using Haversine formula
        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Calculate match score for a property
        function calculateMatchScore(property, locations, priorities) {
            let totalScore = 0;
            let maxPossibleScore = 0;
            const distances = {};

            // Calculate scores for each important location
            Object.keys(locations).forEach(locationType => {
                if (locations[locationType]) {
                    const distance = calculateDistance(
                        property.lat, property.lng,
                        locations[locationType].lat,
                        locations[locationType].lng
                    );
                    
                    distances[locationType] = distance;
                    
                    // Convert distance to score (closer = higher score)
                    const distanceScore = Math.max(0, 100 - (distance * 10)); // 10km = 0 score
                    const priorityWeight = priorities[locationType] / 10;
                    
                    totalScore += distanceScore * priorityWeight;
                    maxPossibleScore += 100 * priorityWeight;
                }
            });

            const finalScore = maxPossibleScore > 0 ? (totalScore / maxPossibleScore) * 100 : 0;
            
            return {
                score: Math.round(finalScore),
                distances: distances
            };
        }

        // Get match category based on score
        function getMatchCategory(score) {
            if (score >= 80) return 'high-match';
            if (score >= 60) return 'medium-match';
            return 'low-match';
        }

        // Main function to find property matches
        async function findPropertyMatches() {
            // Get addresses from fixed locations
            const officeAddress = document.getElementById('office_address').value;
            const schoolAddress = document.getElementById('school_address').value;
            const hospitalAddress = document.getElementById('hospital_address').value;

            // Get priorities from fixed locations
            const priorities = {
                office: parseInt(document.getElementById('office_priority').value),
                school: parseInt(document.getElementById('school_priority').value),
                hospital: parseInt(document.getElementById('hospital_priority').value)
            };

            // Get dynamic locations
            const dynamicLocationsData = {};
            const dynamicPriorities = {};
            
            dynamicLocations.forEach(locationId => {
                const type = document.getElementById(`${locationId}_type`).value;
                const address = document.getElementById(`${locationId}_address`).value;
                const priority = parseInt(document.getElementById(`${locationId}_priority`).value);
                
                if (address) {
                    dynamicLocationsData[type] = address;
                    dynamicPriorities[type] = priority;
                }
            });

            // Combine fixed and dynamic locations
            const allLocations = {
                ...(officeAddress && { office: officeAddress }),
                ...(schoolAddress && { school: schoolAddress }),
                ...(hospitalAddress && { hospital: hospitalAddress }),
                ...dynamicLocationsData
            };
            
            const allPriorities = {
                ...priorities,
                ...dynamicPriorities
            };

            // Validate at least one address is set
            if (Object.keys(allLocations).length === 0) {
                showStatusMessage('Please set at least one important location address.', 'error');
                return;
            }

            showStatusMessage('Geocoding addresses and finding matching properties...', 'info');
            showLoading();

            try {
                // Geocode all addresses
                importantLocations = {};
                
                for (const [type, address] of Object.entries(allLocations)) {
                    importantLocations[type] = await geocodeAddress(address);
                }

                // Calculate match scores for all properties
                matchResults = allData.map(property => {
                    const latCol = findColumn(['Latitude', 'lat', 'latitude']);
                    const lngCol = findColumn(['Longitude', 'lng', 'lon', 'longitude']);
                    
                    if (!latCol || !lngCol) {
                        return {
                            ...property,
                            matchScore: 0,
                            distances: {},
                            matchCategory: 'low-match'
                        };
                    }
                    
                    const lat = parseFloat(property[latCol]);
                    const lng = parseFloat(property[lngCol]);
                    
                    if (!lat || !lng || isNaN(lat) || isNaN(lng)) {
                        return {
                            ...property,
                            matchScore: 0,
                            distances: {},
                            matchCategory: 'low-match'
                        };
                    }
                    
                    const propertyWithCoords = {
                        ...property,
                        lat: lat,
                        lng: lng
                    };
                    
                    const matchInfo = calculateMatchScore(propertyWithCoords, importantLocations, allPriorities);
                    return {
                        ...property,
                        lat: lat,
                        lng: lng,
                        matchScore: matchInfo.score,
                        distances: matchInfo.distances,
                        matchCategory: getMatchCategory(matchInfo.score)
                    };
                });

                // Filter out properties with 0 score and sort by match score
                matchResults = matchResults
                    .filter(property => property.matchScore > 0)
                    .sort((a, b) => b.matchScore - a.matchScore);

                // Set filteredData to match results for display
                filteredData = matchResults;

                // Display results
                displayResults();
                plotPoints();
                updateMatchSummary();

                // Show match summary
                document.getElementById('matchSummary').classList.add('active');
                
                showStatusMessage(`Found ${matchResults.length} matching properties!`, 'success');
            } catch (error) {
                showStatusMessage(error, 'error');
            }
        }

        // Update match summary statistics
        function updateMatchSummary() {
            const highMatches = matchResults.filter(p => p.matchCategory === 'high-match').length;
            const mediumMatches = matchResults.filter(p => p.matchCategory === 'medium-match').length;
            const avgScore = matchResults.length > 0 
                ? Math.round(matchResults.reduce((sum, p) => sum + p.matchScore, 0) / matchResults.length)
                : 0;

            document.getElementById('totalProperties').textContent = matchResults.length;
            document.getElementById('highMatches').textContent = highMatches;
            document.getElementById('mediumMatches').textContent = mediumMatches;
            document.getElementById('avgMatchScore').textContent = avgScore + '%';
        }

        // Reset match finder
        function resetMatchFinder() {
            document.getElementById('office_address').value = '';
            document.getElementById('school_address').value = '';
            document.getElementById('hospital_address').value = '';
            
            // Reset sliders to default values
            document.getElementById('office_priority').value = 5;
            document.getElementById('school_priority').value = 8;
            document.getElementById('hospital_priority').value = 6;
            
            document.getElementById('office_priority_value').textContent = '5';
            document.getElementById('school_priority_value').textContent = '8';
            document.getElementById('hospital_priority_value').textContent = '6';
            
            // Clear dynamic locations
            dynamicLocations.forEach(locationId => {
                removeDynamicLocation(locationId);
            });
            dynamicLocations = [];
            
            matchResults = [];
            document.getElementById('matchSummary').classList.remove('active');
            
            // Reset to show all data
            filteredData = [...allData];
            displayResults();
            plotPoints();
            
            showStatusMessage('Match finder has been reset.', 'info');
        }

        // Load data from published CSV
        async function loadData() {
            try {
                document.getElementById('stats').innerHTML = '<strong>Loading property data from Google Sheets...</strong>';
                showStatusMessage('Loading data from published Google Sheets CSV...', 'info');
                
                const response = await fetch(SHEETS_CSV_URL);
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch CSV: ${response.status}`);
                }
                
                const csvText = await response.text();
                
                // Parse CSV using Papa Parse
                Papa.parse(csvText, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        if (results.errors.length > 0) {
                            console.warn('CSV parsing warnings:', results.errors);
                        }
                        
                        processCSVData(results.data);
                    },
                    error: function(error) {
                        throw new Error(`CSV parsing error: ${error.message}`);
                    }
                });
                
            } catch (error) {
                console.error('Error loading data:', error);
                showError('Error loading data: ' + error.message);
                showStatusMessage('Error: ' + error.message, 'error');
            }
        }

        // Process CSV data
        function processCSVData(data) {
            if (data.length === 0) {
                showError('No data found in the CSV file');
                return;
            }

            // Get headers from the first row keys
            headers = Object.keys(data[0]);
            
            // Process each row
            allData = data.map((row, index) => {
                const rowData = {};
                headers.forEach(header => {
                    rowData[header] = row[header] || '';
                });
                rowData._id = index;
                rowData._rowNumber = index + 2; // +2 because CSV has header row
                return rowData;
            });
            
            console.log('Available columns from CSV:', headers);
            console.log(`Loaded ${allData.length} properties from CSV`);
            
            // Continue with data processing
            processDataAfterLoad();
        }

        async function processDataAfterLoad() {
            filteredData = [...allData];
            displayResults(); // Display results immediately
            await plotPoints();
            
            showStatusMessage(`Successfully loaded ${allData.length} properties from CSV`, 'success');
        }

        async function plotPoints() {
            // Clear existing markers
            markers.forEach(marker => marker.setMap(null));
            infoWindows.forEach(iw => iw.close());
            markers = [];
            infoWindows = [];
            
            const latCol = findColumn(['Latitude', 'lat', 'latitude']);
            const lngCol = findColumn(['Longitude', 'lng', 'lon', 'longitude']);
            const addressCol = findColumn(['Location', 'address', 'location']);
            const nameCol = findColumn(['Project_Name', 'name', 'title', 'property']);
            const bhkCol = findColumn(['BHK', 'bhk']);
            const priceCol = findColumn(['Rent', 'rent', 'price']);
            const areaCol = findColumn(['Area', 'area', 'locality']);
            
            if (!latCol || !lngCol) {
                console.error('Latitude or Longitude columns not found');
                return;
            }
            
            let validPoints = 0;
            const bounds = new google.maps.LatLngBounds();
            
            // Add markers for important locations (if in match finder mode)
            if (matchResults.length > 0 && Object.keys(importantLocations).length > 0) {
                Object.keys(importantLocations).forEach(type => {
                    if (importantLocations[type]) {
                        const location = importantLocations[type];
                        const icon = locationTypes[type]?.icon || '📍';
                        const title = locationTypes[type]?.label || type;
                        
                        const marker = new google.maps.Marker({
                            position: { lat: location.lat, lng: location.lng },
                            map: map,
                            title: `${title}: ${location.address}`,
                            icon: {
                                url: `data:image/svg+xml;charset=UTF-8,<svg width="30" height="30" xmlns="http://www.w3.org/2000/svg"><text x="15" y="20" font-size="20" text-anchor="middle">${icon}</text></svg>`,
                                scaledSize: new google.maps.Size(30, 30),
                                anchor: new google.maps.Point(15, 15)
                            }
                        });
                        
                        markers.push(marker);
                    }
                });
            }
            
            for (const row of filteredData) {
                let lat = parseFloat(row[latCol]);
                let lng = parseFloat(row[lngCol]);
                
                if (!lat || !lng || isNaN(lat) || isNaN(lng)) {
                    continue;
                }
                
                const position = { lat, lng };
                const area = row[areaCol];
                const actualRent = parsePrice(row[priceCol]);
                
                // Check if this property has a match score (from Property Match Finder)
                const matchScore = row.matchScore || 0;
                const matchCategory = row.matchCategory || '';
                
                let markerColor = '#667eea';
                let markerText = formatPriceShort(actualRent);
                
                // If in match finder mode, use match score for coloring
                if (matchResults.length > 0 && matchScore > 0) {
                    if (matchScore >= 80) markerColor = '#4ECDC4';
                    else if (matchScore >= 60) markerColor = '#FFD700';
                    else markerColor = '#FF6B6B';
                    
                    markerText = `${matchScore}%`;
                }
                
                const marker = new google.maps.Marker({
                    position: position,
                    map: map,
                    title: `${row[nameCol]} - ${area}`,
                    icon: {
                        url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
                            <svg width="36" height="24" viewBox="0 0 36 24" xmlns="http://www.w3.org/2000/svg">
                                <rect width="36" height="24" rx="5" ry="5" fill="${markerColor}" stroke="white" stroke-width="2"/>
                                <text x="18" y="15" text-anchor="middle" font-size="10" fill="white" font-weight="bold" font-family="Arial">${markerText}</text>
                            </svg>
                        `),
                        scaledSize: new google.maps.Size(36, 24),
                        anchor: new google.maps.Point(18, 12)
                    }
                });
                
                const infoContent = `
                    <div style="min-width: 250px; padding: 10px;">
                        <h3 style="margin: 0 0 8px 0; color: #333;">${row[nameCol] || 'Property'}</h3>
                        ${actualRent ? `
                            <div style="background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%); padding: 10px; border-radius: 8px; margin-bottom: 8px;">
                                <strong>Actual Rent:</strong> ₹${formatPrice(actualRent)}<br>
                                ${matchScore > 0 ? `<br><strong>Match Score:</strong> ${matchScore}%` : ''}
                            </div>
                        ` : ''}
                        ${bhkCol && row[bhkCol] ? `<p style="margin: 5px 0;"><strong>BHK:</strong> ${row[bhkCol]}</p>` : ''}
                        ${areaCol && row[areaCol] ? `<p style="margin: 5px 0;"><strong>Area:</strong> ${row[areaCol]}</p>` : ''}
                        ${addressCol && row[addressCol] ? `<p style="margin: 5px 0;"><strong>Address:</strong> ${row[addressCol]}</p>` : ''}
                        ${matchScore > 0 && row.distances ? `
                            <div style="font-size: 0.9rem; margin-top: 8px;">
                                <strong>Distances:</strong><br>
                                ${Object.keys(row.distances).map(locationType => {
                                    if (row.distances[locationType]) {
                                        const icon = locationTypes[locationType]?.icon || '📍';
                                        const label = locationTypes[locationType]?.label || locationType;
                                        return `${icon} ${label}: ${row.distances[locationType].toFixed(1)} km<br>`;
                                    }
                                    return '';
                                }).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
                
                const infoWindow = new google.maps.InfoWindow({
                    content: infoContent
                });
                
                marker.addListener('click', () => {
                    infoWindows.forEach(iw => iw.close());
                    infoWindow.open(map, marker);
                });
                
                markers.push(marker);
                infoWindows.push(infoWindow);
                bounds.extend(position);
                validPoints++;
            }
            
            if (markers.length > 0) {
                map.fitBounds(bounds);
            }
            
            updateStats(filteredData.length, validPoints);
        }
        
        function parsePrice(price) {
            if (!price) return 0;
            if (typeof price === 'string') {
                return parseFloat(price.replace(/[^0-9.]/g, ''));
            }
            return parseFloat(price);
        }
        
        function formatPrice(price) {
            return Math.round(parsePrice(price)).toLocaleString('en-IN');
        }
        
        function formatPriceShort(price) {
            price = parsePrice(price);
            if (price >= 100000) {
                return (price / 100000).toFixed(1) + 'L';
            } else if (price >= 1000) {
                return (price / 1000).toFixed(0) + 'K';
            }
            return price.toString();
        }

        function displayResults() {
            const resultsDiv = document.getElementById('results');
            
            if (filteredData.length === 0) {
                resultsDiv.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">No properties found</div>';
                return;
            }
            
            const nameCol = findColumn(['Project_Name', 'name', 'title', 'property']);
            const addressCol = findColumn(['Location', 'address', 'location']);
            const priceCol = findColumn(['Rent', 'rent', 'price']);
            const areaCol = findColumn(['Area', 'area', 'locality']);
            const bhkCol = findColumn(['BHK', 'bhk']);
            const furnishedCol = findColumn(['Furnishing', 'furnished', 'furnish']);
            const parkingCol = findColumn(['Parking', 'parking']);
            const amenitiesCol = findColumn(['Amenities', 'amenities', 'amenity']);
            const carAreaCol = findColumn(['Carpet Area', 'carpet area', 'CarArea', 'Carpet_Area']);
            
            const html = filteredData.map(row => {
                const area = row[areaCol];
                const rent = parsePrice(row[priceCol]);
                const totalParking = calculateTotalParking(row[parkingCol]);
                const matchScore = row.matchScore || 0;
                const matchCategory = row.matchCategory || '';
                
                // Clean up the name and address
                const rawName = nameCol && row[nameCol] ? row[nameCol].trim() : '';
                const rawAddress = addressCol && row[addressCol] ? row[addressCol].trim() : '';

                // Treat "Not Specified" or "NA" or "N/A" as missing
                const isInvalidName = !rawName || 
                                      rawName.toLowerCase() === 'not specified' || 
                                      rawName.toLowerCase() === 'na' || 
                                      rawName.toLowerCase() === 'n/a';

                // Use Location (address) when Project_Name is not specified
                const displayName = !isInvalidName ? rawName : (rawAddress || 'Property');
                
                let amenitiesHTML = '';
                if (amenitiesCol && row[amenitiesCol]) {
                    const amenitiesList = parseAmenities(row[amenitiesCol]);
                    // Show first 5 amenities
                    amenitiesHTML = `
                        <div class="property-amenities">
                            ${amenitiesList.slice(0, 5).map(a => `<span class="amenity-tag-small">${a}</span>`).join('')}
                            ${amenitiesList.length > 5 ? `<span class="amenity-tag-small">+${amenitiesList.length - 5} more</span>` : ''}
                        </div>
                    `;
                }
                
                // Add proximity information if available (from match finder)
                let proximityHTML = '';
                if (matchScore > 0 && row.distances) {
                    const locationItems = Object.keys(row.distances || {}).map(locationType => {
                        if (row.distances[locationType]) {
                            const icon = locationTypes[locationType]?.icon || '📍';
                            return `
                                <div class="proximity-item">
                                    <span>${icon} ${locationTypes[locationType]?.label || locationType}:</span>
                                    <span class="proximity-distance">${row.distances[locationType].toFixed(1)} km</span>
                                </div>
                            `;
                        }
                        return '';
                    }).join('');
                    
                    proximityHTML = `
                        <div class="property-proximity">
                            ${locationItems}
                        </div>
                    `;
                }
                
                return `
                    <div class="property-card ${matchCategory}" style="border-left-color: #667eea">
                        ${matchScore > 0 ? `<span class="match-score">${matchScore}% Match</span>` : ''}
                        <div class='property-name1'>
                        <div class="property-name">${displayName}</div>
                        <div class="property-rent">₹${formatPrice(rent)}/month</div>
                        </div>
                        <div class="property-details">
                            ${bhkCol && row[bhkCol] ? `<span class="detail-tag">${row[bhkCol]} BHK</span>` : ''}
                            ${carAreaCol && row[carAreaCol] ? `<span class="detail-tag">${row[carAreaCol]}</span>` : ''}
                            ${areaCol && row[areaCol] ? `<span class="detail-tag">${area}</span>` : ''}
                            ${furnishedCol && row[furnishedCol] ? `<span class="detail-tag">${row[furnishedCol]}</span>` : ''}
                            ${totalParking > 0 ? `<span class="detail-tag">${totalParking} Parking</span>` : ''}
                        </div>
                        ${amenitiesHTML}
                        ${proximityHTML}
                    </div>
                `;
            }).join('');
            
            resultsDiv.innerHTML = html;
        }
        
        function updateStats(total, visible) {
            const statsDiv = document.getElementById('stats');
            
            if (matchResults.length > 0) {
                statsDiv.innerHTML = `
                    <strong>Showing ${visible} of ${total} matching properties</strong><br>
                    <small>Based on proximity to your important locations</small>
                `;
            } else {
                statsDiv.innerHTML = `
                    <strong>Showing ${visible} of ${total} properties</strong><br>
                    <small>Enter your important locations to find matching properties</small>
                `;
            }
        }
        
        function calculateTotalParking(parkingStr) {
            if (!parkingStr) return 0;
            
            const numbers = parkingStr.match(/\d+/g);
            if (!numbers) return 0;
            
            return numbers.reduce((total, num) => total + parseInt(num), 0);
        }
        
        function parseAmenities(amenitiesStr) {
            if (!amenitiesStr) return [];
            amenitiesStr = amenitiesStr.replace(/[\[\]']/g, '');
            return amenitiesStr.split(',').map(a => a.trim()).filter(a => a.length > 0);
        }
        
        function showError(message) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = `<div class="error">${message}</div>`;
        }

        function showStatusMessage(message, type = 'info') {
            const statusDiv = document.getElementById('statusMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'status-message';
            
            if (type === 'error') {
                messageDiv.style.background = '#ffe6e6';
                messageDiv.style.color = '#d63031';
                messageDiv.style.borderLeftColor = '#d63031';
            } else if (type === 'success') {
                messageDiv.style.background = '#e6f7e6';
                messageDiv.style.color = '#27ae60';
                messageDiv.style.borderLeftColor = '#27ae60';
            } else if (type === 'warning') {
                messageDiv.style.background = '#fff8e6';
                messageDiv.style.color = '#f39c12';
                messageDiv.style.borderLeftColor = '#f39c12';
            }
            
            messageDiv.textContent = message;
            statusDiv.appendChild(messageDiv);
            
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.parentNode.removeChild(messageDiv);
                }
            }, 5000);
        }

        // Show loading indicator for match finder
        function showLoading() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = `
                <div class="loading">
                    <div style="border: 4px solid #f3f3f3; border-top: 4px solid #667eea; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 0 auto 15px;"></div>
                    <p>Analyzing properties based on your location preferences...</p>
                </div>
            `;
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            // Show welcome message
            showStatusMessage('Welcome! Enter your important locations to find matching properties.', 'success');
        });
        
        // Error handling for Google Maps API
        window.gm_authFailure = function() {
            showStatusMessage('Google Maps authentication failed. Please check your API key.', 'error');
        };
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBBcaIOoP7kpoXy1sDs2MHX1yj92bzBbGo&callback=initMap&libraries=places,geometry"></script>
</body>
</html>