<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Property Match Finder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #666;
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
            width: 100%;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2.2rem;
            margin-bottom: 8px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 0.9rem;
        }

        /* Property Match Finder Section */
        .match-finder-section {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            border-left: 4px solid #FF6B6B;
        }

        .match-finder-section h3 {
            margin-bottom: 20px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.3rem;
        }

        /* Dynamic Location Groups */
        .dynamic-locations {
            margin-bottom: 20px;
        }

        .dynamic-location-group {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            padding: 15px;
            border: 2px solid #e0e0e0;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .dynamic-location-group:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }

        .dynamic-location-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .dynamic-location-header h4 {
            color: #333;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1.1rem;
        }

        .remove-location {
            background: #FF6B6B;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 12px;
        }

        .dynamic-location-content {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 15px;
        }

        .location-input-group {
            margin-bottom: 12px;
            position: relative;
        }

        .location-input-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
            color: #555;
            font-size: 0.9rem;
        }

        .location-input-group input, .location-input-group select {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .location-input-group input:focus, .location-input-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .priority-slider {
            margin-top: 15px;
        }

        .priority-slider label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
            font-size: 0.9rem;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider-value {
            min-width: 40px;
            text-align: center;
            font-weight: bold;
            color: #667eea;
        }

        input[type="range"] {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: #e0e0e0;
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
        }

        .add-location-btn {
            background: linear-gradient(45deg, #4ECDC4, #44A08D);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 10px 20px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 0 auto;
            transition: all 0.3s ease;
        }

        .add-location-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.4);
        }

        .match-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
            flex-wrap: wrap;
        }

        .match-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .match-btn.primary {
            background: linear-gradient(45deg, #FF6B6B, #FF8E53);
            color: white;
        }

        .match-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }

        .match-btn.secondary {
            background: #f8f9fa;
            color: #333;
            border: 2px solid #e0e0e0;
        }

        .match-btn.secondary:hover {
            background: #e9ecef;
        }

        .content-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: 600px;
        }

        .results-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px;
            overflow-y: auto;
            height: 600px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .map-container {
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            position: relative;
        }

        #map {
            height: 100%;
            width: 100%;
        }

        /* Search Bar Styles */
        .search-container {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            z-index: 10;
        }

        .search-box {
            display: flex;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .search-input {
            flex: 1;
            border: none;
            padding: 12px 16px;
            font-size: 16px;
            outline: none;
        }

        .search-button {
            background: #667eea;
            color: white;
            border: none;
            padding: 0 20px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .search-button:hover {
            background: #5a6fd8;
        }

        .property-card {
            background: white;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            cursor: pointer;
            border-left: 4px solid #667eea;
            position: relative;
        }
        
        .property-card.high-match {
            border-left: 4px solid #4ECDC4;
            background: linear-gradient(45deg, #f0fff0, #e6ffe6);
        }

        .property-card.medium-match {
            border-left: 4px solid #FFD700;
            background: linear-gradient(45deg, #fffaf0, #fff5e6);
        }

        .property-card.low-match {
            border-left: 4px solid #FF6B6B;
            background: linear-gradient(45deg, #fff0f0, #ffe6e6);
        }

        .property-name1{
            display:flex;
            justify-content: space-between;
        }

        .property-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        .property-name {
            font-size: 1.1rem;
            font-weight: bold;
            color: #333;
            margin-bottom: 6px;
        }

        .property-rent {
            font-size: 1rem;
            color: #667eea;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .property-details {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            margin-bottom: 8px;
        }

        .detail-tag {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 3px 6px;
            border-radius: 10px;
            font-size: 0.75rem;
            white-space: nowrap;
        }

        .property-amenities {
            display: flex;
            gap: 3px;
            margin-top: 6px;
            flex-wrap: wrap;
        }

        .amenity-tag-small {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.5rem;
            text-align: center;
        }

        .stats {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 12px;
            border-radius: 12px;
            margin-bottom: 15px;
            text-align: center;
        }

        .loading {
            text-align: center;
            padding: 15px;
            color: #667eea;
            font-weight: bold;
        }

        .error {
            background: #ffe6e6;
            color: #d63031;
            padding: 8px;
            border-radius: 8px;
            margin: 8px 0;
        }

        .status-message {
            background: #e3f2fd;
            color: #1976d2;
            padding: 8px 12px;
            border-radius: 8px;
            margin: 8px 0;
            border-left: 4px solid #1976d2;
            font-size: 0.9rem;
        }

        /* Match Score Indicator */
        .match-score {
            display: inline-block;
            background: linear-gradient(45deg, #4ECDC4, #44A08D);
            color: white;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-left: 10px;
        }

        .property-card .match-score {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 0.7rem;
        }

        /* Match Results Summary */
        .match-summary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            display: none;
        }

        .match-summary.active {
            display: block;
        }

        .match-summary h4 {
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .match-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .stat-item {
            text-align: center;
            padding: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.8rem;
            opacity: 0.9;
        }

        /* Property proximity info */
        .property-proximity {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #eee;
        }

        .proximity-item {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            margin-bottom: 4px;
            color: #666;
        }

        .proximity-distance {
            font-weight: bold;
            color: #667eea;
        }

        /* Address examples */
        .address-examples {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #4ECDC4;
        }

        .address-examples h5 {
            margin-bottom: 10px;
            color: #333;
        }

        .example-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }

        .example-item {
            font-size: 0.85rem;
            color: #666;
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            transition: background 0.3s;
        }

        .example-item:hover {
            background: #e9ecef;
        }

        /* Add to Important Locations Button */
        .add-to-important-btn {
            background: linear-gradient(45deg, #4ECDC4, #44A08D);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 10px;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.3s ease;
        }

        .add-to-important-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(78, 205, 196, 0.3);
        }

        /* Modal for selecting location type */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 20px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .modal-title {
            font-size: 1.2rem;
            font-weight: bold;
            color: #333;
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
        }

        .modal-body {
            margin-bottom: 20px;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .modal-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
        }

        .modal-btn.primary {
            background: #667eea;
            color: white;
        }

        .modal-btn.secondary {
            background: #f8f9fa;
            color: #333;
            border: 1px solid #e0e0e0;
        }

        /* Autocomplete dropdown styling */
        .pac-container {
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border: none;
            margin-top: 5px;
        }

        .pac-item {
            padding: 8px 12px;
            border-bottom: 1px solid #f0f0f0;
            font-size: 14px;
        }

        .pac-item:hover {
            background-color: #f5f5f5;
        }

        .pac-item-selected {
            background-color: #e3f2fd;
        }

        .pac-icon {
            margin-top: 5px;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .content-area {
                grid-template-columns: 1fr;
                height: auto;
                gap: 12px;
            }

            /* Make map smaller on top */
            .map-container {
                height: 40vh;
                order: 1;
            }

            /* Make cards fill remaining space */
            .results-panel {
                height: 50vh;
                max-height: none;
                overflow-y: auto;
                order: 2;
            }

            .property-card {
                margin-bottom: 10px;
                padding: 12px;
            }

            .property-name {
                font-size: 1rem;
            }

            .property-rent {
                font-size: 0.9rem;
            }

            .property-details {
                gap: 2px;
            }

            .detail-tag {
                font-size: 0.65rem;
                padding: 2px 5px;
            }

            .amenity-tag-small {
                font-size: 0.6rem;
                padding: 2px 5px;
            }

            .dynamic-location-content {
                grid-template-columns: 1fr;
            }
            
            .match-actions {
                flex-direction: column;
            }
            
            .match-btn {
                width: 100%;
            }
            
            .search-container {
                position: relative;
                top: 0;
                left: 0;
                right: 0;
                margin-bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div>
                <h1>🏠 Property Match Finder</h1>
                <p>Find your perfect home based on proximity to important locations</p>
            </div>
        </div>

        <!-- Property Match Finder Section -->
        <div class="match-finder-section">
            <h3>🎯 Set Your Important Locations</h3>
            
            <!-- Dynamic Location Groups -->
            <div class="dynamic-locations" id="dynamicLocations">
                <!-- Dynamic location groups will be added here -->
            </div>
            
            <button class="add-location-btn" onclick="addDynamicLocation()">
                ➕ Add Another Location
            </button>

            <div class="address-examples">
                <h5>💡 Example Addresses (Click to use):</h5>
                <div class="example-list">
                    <div class="example-item" onclick="useExample('Bandra Kurla Complex, Mumbai')">Bandra Kurla Complex, Mumbai</div>
                    <div class="example-item" onclick="useExample('Nariman Point, Mumbai')">Nariman Point, Mumbai</div>
                    <div class="example-item" onclick="useExample('Dhirubhai Ambani International School, Mumbai')">Dhirubhai Ambani School</div>
                    <div class="example-item" onclick="useExample('Jamnabai Narsee School, Juhu')">Jamnabai Narsee School</div>
                    <div class="example-item" onclick="useExample('Lilavati Hospital, Bandra')">Lilavati Hospital, Bandra</div>
                    <div class="example-item" onclick="useExample('Kokilaben Hospital, Andheri')">Kokilaben Hospital</div>
                </div>
            </div>

            <div class="match-actions">
                <button class="match-btn primary" onclick="findPropertyMatches()">
                    🔍 Find Matching Properties
                </button>
                <button class="match-btn secondary" onclick="resetMatchFinder()">
                    🔄 Reset
                </button>
            </div>
        </div>

        <!-- Match Results Summary -->
        <div class="match-summary" id="matchSummary">
            <h4>📊 Property Match Results</h4>
            <div class="match-stats">
                <div class="stat-item">
                    <div class="stat-value" id="totalProperties">0</div>
                    <div class="stat-label">Properties (60%+)</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="highMatches">0</div>
                    <div class="stat-label">High Matches</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="mediumMatches">0</div>
                    <div class="stat-label">Medium Matches</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="avgMatchScore">0%</div>
                    <div class="stat-label">Avg Match Score</div>
                </div>
            </div>
        </div>

        <!-- Content Area -->
        <div class="content-area">
            <div class="results-panel">
                <div class="stats" id="stats">
                    <strong>Enter your important locations to find matching properties</strong>
                </div>
                <div id="statusMessages"></div>
                <div id="results"></div>
            </div>
            <div class="map-container">
                <!-- Search Bar -->
                <div class="search-container">
                    <div class="search-box">
                        <input type="text" id="address-search" class="search-input" placeholder="Search for an address or place...">
                        <button class="search-button" onclick="searchAddress()">🔍</button>
                    </div>
                </div>
                <div id="map"></div>
            </div>
        </div>
    </div>

    <!-- Modal for adding searched address to important locations -->
    <div class="modal" id="addLocationModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Add to Important Locations</div>
                <button class="close-modal" onclick="closeAddLocationModal()">&times;</button>
            </div>
            <div class="modal-body">
                <p>Add the searched address to your important locations:</p>
                <div class="location-input-group" style="margin-top: 15px;">
                    <label for="modal_location_type">Location Type</label>
                    <select id="modal_location_type">
                        <option value="office">🏢 Office</option>
                        <option value="school">🏫 School</option>
                        <option value="hospital">🏥 Hospital</option>
                        <option value="gym">💪 Gym/Fitness Center</option>
                        <option value="temple">🛕 Temple</option>
                        <option value="mosque">🕌 Mosque</option>
                        <option value="market">🛒 Market/Shopping</option>
                        <option value="park">🌳 Park/Recreation</option>
                        <option value="restaurant">🍽️ Restaurant/Food</option>
                        <option value="transport">🚇 Transport Hub</option>
                        <option value="other" selected>📍 Other Important Location</option>
                    </select>
                </div>
                <div class="location-input-group">
                    <label for="modal_location_priority">Priority</label>
                    <div class="slider-container">
                        <input type="range" id="modal_location_priority" min="1" max="10" value="5">
                        <span class="slider-value" id="modal_priority_value">5</span>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn secondary" onclick="closeAddLocationModal()">Cancel</button>
                <button class="modal-btn primary" onclick="addSearchedLocation()">Add Location</button>
            </div>
        </div>
    </div>

    <script>
        // Your published Google Sheets CSV URL
        const SHEETS_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTMjpsUGc_KrCMECutLvsLTLva3BOaOX8H4bvvE8XA7qRltqJjY3Y7_zgvwr2MsKIjCJquXHg6UsErg/pub?output=csv';
        
        // Location types and their icons
        const locationTypes = {
            'office': { icon: '🏢', label: 'Office' },
            'school': { icon: '🏫', label: 'School' },
            'hospital': { icon: '🏥', label: 'Hospital' },
            'gym': { icon: '💪', label: 'Gym/Fitness Center' },
            'temple': { icon: '🛕', label: 'Temple' },
            'mosque': { icon: '🕌', label: 'Mosque' },
            'market': { icon: '🛒', label: 'Market/Shopping' },
            'park': { icon: '🌳', label: 'Park/Recreation' },
            'restaurant': { icon: '🍽️', label: 'Restaurant/Food' },
            'transport': { icon: '🚇', label: 'Transport Hub' },
            'other': { icon: '📍', label: 'Other Important Location' }
        };

        let map;
        let markers = [];
        let allData = [];
        let filteredData = [];
        let headers = [];
        let infoWindows = [];
        let geocoder;
        let autocomplete;
        let searchAutocomplete;
        let searchMarker;
        let currentSearchedAddress = '';
        
        // Property Match Finder variables
        let matchResults = [];
        let importantLocations = {};
        let dynamicLocations = []; // For storing dynamic location inputs
        let dynamicAutocompletes = []; // Store autocomplete instances for dynamic location inputs

        // Initialize with one location by default
        document.addEventListener('DOMContentLoaded', function() {
            // Show welcome message
            showStatusMessage('Welcome! Enter your important locations to find matching properties.', 'success');
            
            // Add one initial location
            addDynamicLocation();
        });

        function findColumn(possibleNames) {
            for (let name of possibleNames) {
                const exactMatch = headers.find(h => h && h.toLowerCase() === name.toLowerCase());
                if (exactMatch) return exactMatch;
                
                const containsMatch = headers.find(h => h && h.toLowerCase().includes(name.toLowerCase()));
                if (containsMatch) return containsMatch;
            }
            return null;
        }
        
        function initMap() {
            showStatusMessage('Google Maps loaded successfully!', 'success');
            map = new google.maps.Map(document.getElementById('map'), {
                center: { lat: 19.0760, lng: 72.8777 }, // Mumbai coordinates
                zoom: 12,
                styles: [
                    {
                        featureType: "poi",
                        elementType: "labels",
                        stylers: [{ visibility: "off" }]
                    }
                ]
            });
            
            geocoder = new google.maps.Geocoder();
            
            // Initialize priority sliders
            initializePrioritySliders();
            
            // Initialize autocomplete after a short delay to ensure DOM is ready
            setTimeout(() => {
                checkGoogleMapsReady();
            }, 500);
            
            loadData();
        }

        // Check if Google Maps API is ready and initialize autocomplete
        function checkGoogleMapsReady() {
            if (typeof google !== 'undefined' && google.maps && google.maps.places) {
                initAutocomplete();
                initSearchAutocomplete();
            } else {
                setTimeout(checkGoogleMapsReady, 100);
            }
        }

        // Initialize Google Places Autocomplete for all address inputs
        function initAutocomplete() {
            // Reinitialize autocomplete for all existing dynamic location inputs
            reinitializeAllAutocompletes();
        }

        // Reinitialize autocomplete for all dynamic location inputs
        function reinitializeAllAutocompletes() {
            // Clear existing autocomplete instances
            dynamicAutocompletes.forEach(autocomplete => {
                if (autocomplete) {
                    google.maps.event.clearInstanceListeners(autocomplete);
                }
            });
            dynamicAutocompletes = [];

            // Initialize autocomplete for all existing dynamic location inputs
            dynamicLocations.forEach(locationId => {
                const addressInput = document.getElementById(`${locationId}_address`);
                if (addressInput) {
                    const autocomplete = initAutocompleteForInput(addressInput);
                    dynamicAutocompletes.push(autocomplete);
                }
            });
        }

        // Initialize autocomplete for a specific input element
        function initAutocompleteForInput(inputElement) {
            // Clear any existing event listeners
            google.maps.event.clearInstanceListeners(inputElement);
            
            const autocomplete = new google.maps.places.Autocomplete(inputElement, {
                types: ['geocode', 'establishment'],
                componentRestrictions: { country: 'in' }
            });
            
            autocomplete.addListener('place_changed', function() {
                const place = autocomplete.getPlace();
                if (place.geometry) {
                    showStatusMessage(`Location set to: ${place.formatted_address}`, 'success');
                }
            });
            
            // Prevent form submission when pressing Enter on autocomplete
            inputElement.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                }
            });
            
            return autocomplete;
        }

        // Initialize search autocomplete
        function initSearchAutocomplete() {
            const searchInput = document.getElementById('address-search');
            searchAutocomplete = new google.maps.places.Autocomplete(searchInput, {
                types: ['geocode', 'establishment'],
                componentRestrictions: { country: 'in' }
            });
            
            searchAutocomplete.addListener('place_changed', function() {
                const place = searchAutocomplete.getPlace();
                if (place.geometry) {
                    // Center map on selected location
                    map.setCenter(place.geometry.location);
                    map.setZoom(15);
                    
                    // Add a marker for the searched location
                    if (searchMarker) {
                        searchMarker.setMap(null);
                    }
                    
                    searchMarker = new google.maps.Marker({
                        position: place.geometry.location,
                        map: map,
                        title: place.name,
                        icon: {
                            url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
                                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <circle cx="12" cy="12" r="10" fill="#FF6B6B" stroke="white" stroke-width="2"/>
                                    <text x="12" y="16" text-anchor="middle" font-size="10" fill="white" font-weight="bold">📍</text>
                                </svg>
                            `),
                            scaledSize: new google.maps.Size(24, 24),
                            anchor: new google.maps.Point(12, 12)
                        }
                    });
                    
                    // Store the searched address
                    currentSearchedAddress = place.formatted_address;
                    
                    // Show info window with place details and "Add to Important" button
                    const infoWindow = new google.maps.InfoWindow({
                        content: `
                            <div style="min-width: 200px;">
                                <h3 style="margin: 0 0 8px 0; color: #333;">${place.name}</h3>
                                <p style="margin: 0; color: #666;">${place.formatted_address}</p>
                                <button class="add-to-important-btn" onclick="openAddLocationModal('${place.formatted_address.replace(/'/g, "\\'")}')">
                                    ➕ Add to Important Locations
                                </button>
                            </div>
                        `
                    });
                    
                    infoWindow.open(map, searchMarker);
                    
                    showStatusMessage(`Showing location: ${place.name}`, 'success');
                }
            });
            
            // Add event listener for Enter key
            searchInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    searchAddress();
                }
            });
        }

        // Search for address
        function searchAddress() {
            const address = document.getElementById('address-search').value;
            if (!address) {
                showStatusMessage('Please enter an address to search.', 'warning');
                return;
            }
            
            geocoder.geocode({ address: address }, function(results, status) {
                if (status === 'OK' && results[0]) {
                    // Center map on searched location
                    map.setCenter(results[0].geometry.location);
                    map.setZoom(15);
                    
                    // Add a marker for the searched location
                    if (searchMarker) {
                        searchMarker.setMap(null);
                    }
                    
                    searchMarker = new google.maps.Marker({
                        position: results[0].geometry.location,
                        map: map,
                        title: address,
                        icon: {
                            url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
                                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <circle cx="12" cy="12" r="10" fill="#FF6B6B" stroke="white" stroke-width="2"/>
                                    <text x="12" y="16" text-anchor="middle" font-size="10" fill="white" font-weight="bold">📍</text>
                                </svg>
                            `),
                            scaledSize: new google.maps.Size(24, 24),
                            anchor: new google.maps.Point(12, 12)
                        }
                    });
                    
                    // Store the searched address
                    currentSearchedAddress = results[0].formatted_address;
                    
                    // Show info window with place details and "Add to Important" button
                    const infoWindow = new google.maps.InfoWindow({
                        content: `
                            <div style="min-width: 200px;">
                                <h3 style="margin: 0 0 8px 0; color: #333;">Searched Location</h3>
                                <p style="margin: 0; color: #666;">${results[0].formatted_address}</p>
                                <button class="add-to-important-btn" onclick="openAddLocationModal('${results[0].formatted_address.replace(/'/g, "\\'")}')">
                                    ➕ Add to Important Locations
                                </button>
                            </div>
                        `
                    });
                    
                    infoWindow.open(map, searchMarker);
                    
                    showStatusMessage(`Showing location: ${results[0].formatted_address}`, 'success');
                } else {
                    showStatusMessage('Location not found. Please try a different address.', 'error');
                }
            });
        }

        // Open modal to add searched location to important locations
        function openAddLocationModal(address) {
            currentSearchedAddress = address;
            document.getElementById('addLocationModal').style.display = 'flex';
            
            // Initialize modal slider
            const modalSlider = document.getElementById('modal_location_priority');
            const modalValueSpan = document.getElementById('modal_priority_value');
            modalSlider.addEventListener('input', function() {
                modalValueSpan.textContent = this.value;
            });
        }

        // Close the add location modal
        function closeAddLocationModal() {
            document.getElementById('addLocationModal').style.display = 'none';
        }

        // Add searched location to important locations
        function addSearchedLocation() {
            const type = document.getElementById('modal_location_type').value;
            const priority = parseInt(document.getElementById('modal_location_priority').value);
            
            // Add a new dynamic location
            addDynamicLocation();
            
            // Set the values for the new location
            setTimeout(() => {
                const lastLocationId = dynamicLocations[dynamicLocations.length - 1];
                const typeSelect = document.getElementById(`${lastLocationId}_type`);
                const addressInput = document.getElementById(`${lastLocationId}_address`);
                const prioritySlider = document.getElementById(`${lastLocationId}_priority`);
                const priorityValue = document.getElementById(`${lastLocationId}_priority_value`);
                
                if (typeSelect && addressInput && prioritySlider && priorityValue) {
                    typeSelect.value = type;
                    addressInput.value = currentSearchedAddress;
                    prioritySlider.value = priority;
                    priorityValue.textContent = priority;
                    
                    // Update the location icon
                    updateDynamicLocationIcon(lastLocationId);
                    
                    // Initialize autocomplete for the new address input
                    initAutocompleteForInput(addressInput);
                    
                    showStatusMessage(`Added "${currentSearchedAddress}" to important locations as ${locationTypes[type].label}`, 'success');
                }
            }, 100);
            
            closeAddLocationModal();
        }

        // Initialize priority sliders for Property Match Finder
        function initializePrioritySliders() {
            const sliders = document.querySelectorAll('.priority-slider');
            sliders.forEach(slider => {
                const valueSpan = slider.parentElement.querySelector('.slider-value');
                slider.addEventListener('input', function() {
                    valueSpan.textContent = this.value;
                });
            });
        }

        // Add a dynamic location input group
        function addDynamicLocation() {
            const dynamicLocationsDiv = document.getElementById('dynamicLocations');
            const locationId = 'dynamic_' + Date.now();
            
            const locationGroup = document.createElement('div');
            locationGroup.className = 'dynamic-location-group';
            locationGroup.id = locationId;
            
            locationGroup.innerHTML = `
                <div class="dynamic-location-header">
                    <h4>📍 Important Location</h4>
                    <button class="remove-location" onclick="removeDynamicLocation('${locationId}')">Remove</button>
                </div>
                <div class="dynamic-location-content">
                    <div class="location-input-group">
                        <label for="${locationId}_type">Location Type</label>
                        <select id="${locationId}_type" onchange="updateDynamicLocationIcon('${locationId}')">
                            ${Object.keys(locationTypes).map(type => 
                                `<option value="${type}">${locationTypes[type].icon} ${locationTypes[type].label}</option>`
                            ).join('')}
                        </select>
                    </div>
                    <div class="location-input-group">
                        <label for="${locationId}_address">Address</label>
                        <input type="text" id="${locationId}_address" placeholder="Enter address...">
                    </div>
                </div>
                <div class="priority-slider">
                    <label>Priority: <span class="slider-value" id="${locationId}_priority_value">5</span></label>
                    <div class="slider-container">
                        <input type="range" id="${locationId}_priority" min="1" max="10" value="5" class="priority-slider">
                    </div>
                </div>
            `;
            
            dynamicLocationsDiv.appendChild(locationGroup);
            
            // Initialize the slider for this new location
            const slider = document.getElementById(`${locationId}_priority`);
            const valueSpan = document.getElementById(`${locationId}_priority_value`);
            slider.addEventListener('input', function() {
                valueSpan.textContent = this.value;
            });
            
            // Initialize autocomplete for the new address input
            const addressInput = document.getElementById(`${locationId}_address`);
            if (addressInput && typeof google !== 'undefined' && google.maps && google.maps.places) {
                const autocomplete = initAutocompleteForInput(addressInput);
                dynamicAutocompletes.push(autocomplete);
            }
            
            dynamicLocations.push(locationId);
            
            // Update the location icon immediately
            updateDynamicLocationIcon(locationId);
        }

        // Update dynamic location icon when type changes
        function updateDynamicLocationIcon(locationId) {
            const typeSelect = document.getElementById(`${locationId}_type`);
            const header = document.querySelector(`#${locationId} .dynamic-location-header h4`);
            const selectedType = typeSelect.value;
            
            header.innerHTML = `${locationTypes[selectedType].icon} ${locationTypes[selectedType].label}`;
        }

        // Remove a dynamic location
        function removeDynamicLocation(locationId) {
            const element = document.getElementById(locationId);
            if (element) {
                // Find and clean up the autocomplete instance
                const addressInput = document.getElementById(`${locationId}_address`);
                if (addressInput) {
                    google.maps.event.clearInstanceListeners(addressInput);
                }
                
                element.remove();
                dynamicLocations = dynamicLocations.filter(id => id !== locationId);
                
                // Reinitialize autocompletes to ensure they work properly
                setTimeout(() => {
                    reinitializeAllAutocompletes();
                }, 100);
            }
        }

        // Use example address
        function useExample(address) {
            // Add a new location with the example address
            addDynamicLocation();
            
            // Set the address in the most recently added location
            setTimeout(() => {
                const lastLocationId = dynamicLocations[dynamicLocations.length - 1];
                const addressInput = document.getElementById(`${lastLocationId}_address`);
                if (addressInput) {
                    addressInput.value = address;
                    showStatusMessage(`Added example address: ${address}`, 'success');
                }
            }, 200);
        }

        // Geocode an address to get coordinates
        function geocodeAddress(address) {
            return new Promise((resolve, reject) => {
                geocoder.geocode({ address: address }, function(results, status) {
                    if (status === 'OK' && results[0]) {
                        resolve({
                            lat: results[0].geometry.location.lat(),
                            lng: results[0].geometry.location.lng(),
                            address: results[0].formatted_address
                        });
                    } else {
                        reject(`Geocoding failed for: ${address}. Status: ${status}`);
                    }
                });
            });
        }

        // Calculate distance between two coordinates using Haversine formula
        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Calculate match score for a property
        function calculateMatchScore(property, locations, priorities) {
            let totalScore = 0;
            let maxPossibleScore = 0;
            const distances = {};

            // Calculate scores for each important location
            Object.keys(locations).forEach(locationType => {
                if (locations[locationType]) {
                    const distance = calculateDistance(
                        property.lat, property.lng,
                        locations[locationType].lat,
                        locations[locationType].lng
                    );
                    
                    distances[locationType] = distance;
                    
                    // Convert distance to score (closer = higher score)
                    const distanceScore = Math.max(0, 100 - (distance * 10)); // 10km = 0 score
                    const priorityWeight = priorities[locationType] / 10;
                    
                    totalScore += distanceScore * priorityWeight;
                    maxPossibleScore += 100 * priorityWeight;
                }
            });

            const finalScore = maxPossibleScore > 0 ? (totalScore / maxPossibleScore) * 100 : 0;
            
            return {
                score: Math.round(finalScore),
                distances: distances
            };
        }

        // Get match category based on score
        function getMatchCategory(score) {
            if (score >= 80) return 'high-match';
            if (score >= 60) return 'medium-match';
            return 'low-match';
        }

        // Main function to find property matches
        async function findPropertyMatches() {
            // Get all dynamic locations
            const allLocations = {};
            const allPriorities = {};
            
            dynamicLocations.forEach(locationId => {
                const type = document.getElementById(`${locationId}_type`).value;
                const address = document.getElementById(`${locationId}_address`).value;
                const priority = parseInt(document.getElementById(`${locationId}_priority`).value);
                
                if (address) {
                    allLocations[type] = address;
                    allPriorities[type] = priority;
                }
            });

            // Validate at least one address is set
            if (Object.keys(allLocations).length === 0) {
                showStatusMessage('Please set at least one important location address.', 'error');
                return;
            }

            showStatusMessage('Geocoding addresses and finding matching properties...', 'info');
            showLoading();

            try {
                // Geocode all addresses
                importantLocations = {};
                
                for (const [type, address] of Object.entries(allLocations)) {
                    importantLocations[type] = await geocodeAddress(address);
                }

                // Calculate match scores for all properties
                matchResults = allData.map(property => {
                    const latCol = findColumn(['Latitude', 'lat', 'latitude']);
                    const lngCol = findColumn(['Longitude', 'lng', 'lon', 'longitude']);
                    
                    if (!latCol || !lngCol) {
                        return {
                            ...property,
                            matchScore: 0,
                            distances: {},
                            matchCategory: 'low-match'
                        };
                    }
                    
                    const lat = parseFloat(property[latCol]);
                    const lng = parseFloat(property[lngCol]);
                    
                    if (!lat || !lng || isNaN(lat) || isNaN(lng)) {
                        return {
                            ...property,
                            matchScore: 0,
                            distances: {},
                            matchCategory: 'low-match'
                        };
                    }
                    
                    const propertyWithCoords = {
                        ...property,
                        lat: lat,
                        lng: lng
                    };
                    
                    const matchInfo = calculateMatchScore(propertyWithCoords, importantLocations, allPriorities);
                    return {
                        ...property,
                        lat: lat,
                        lng: lng,
                        matchScore: matchInfo.score,
                        distances: matchInfo.distances,
                        matchCategory: getMatchCategory(matchInfo.score)
                    };
                });

                // MODIFIED: Filter out properties with score less than 60% and sort by match score
                matchResults = matchResults
                    .filter(property => property.matchScore >= 60) // Only show 60%+ matches
                    .sort((a, b) => b.matchScore - a.matchScore);

                // Set filteredData to match results for display
                filteredData = matchResults;

                // Display results
                displayResults();
                plotPoints();
                updateMatchSummary();

                // Show match summary
                document.getElementById('matchSummary').classList.add('active');
                
                if (matchResults.length === 0) {
                    showStatusMessage('No properties found with 60% or higher match score.', 'warning');
                } else {
                    showStatusMessage(`Found ${matchResults.length} properties with 60%+ match score!`, 'success');
                }
            } catch (error) {
                showStatusMessage(error, 'error');
            }
        }

        // Update match summary statistics
        function updateMatchSummary() {
            const highMatches = matchResults.filter(p => p.matchCategory === 'high-match').length;
            const mediumMatches = matchResults.filter(p => p.matchCategory === 'medium-match').length;
            const avgScore = matchResults.length > 0 
                ? Math.round(matchResults.reduce((sum, p) => sum + p.matchScore, 0) / matchResults.length)
                : 0;

            document.getElementById('totalProperties').textContent = matchResults.length;
            document.getElementById('highMatches').textContent = highMatches;
            document.getElementById('mediumMatches').textContent = mediumMatches;
            document.getElementById('avgMatchScore').textContent = avgScore + '%';
        }

        // Reset match finder
        function resetMatchFinder() {
            // Clear all dynamic locations
            const dynamicLocationsDiv = document.getElementById('dynamicLocations');
            dynamicLocationsDiv.innerHTML = '';
            dynamicLocations = [];
            
            // Add one default location
            addDynamicLocation();
            
            matchResults = [];
            document.getElementById('matchSummary').classList.remove('active');
            
            // Reset to show all data
            filteredData = [...allData];
            displayResults();
            plotPoints();
            
            showStatusMessage('Match finder has been reset.', 'info');
        }

        // Load data from published CSV
        async function loadData() {
            try {
                document.getElementById('stats').innerHTML = '<strong>Loading property data from Google Sheets...</strong>';
                showStatusMessage('Loading data from published Google Sheets CSV...', 'info');
                
                const response = await fetch(SHEETS_CSV_URL);
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch CSV: ${response.status}`);
                }
                
                const csvText = await response.text();
                
                // Parse CSV using Papa Parse
                Papa.parse(csvText, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        if (results.errors.length > 0) {
                            console.warn('CSV parsing warnings:', results.errors);
                        }
                        
                        processCSVData(results.data);
                    },
                    error: function(error) {
                        throw new Error(`CSV parsing error: ${error.message}`);
                    }
                });
                
            } catch (error) {
                console.error('Error loading data:', error);
                showError('Error loading data: ' + error.message);
                showStatusMessage('Error: ' + error.message, 'error');
            }
        }

        // Process CSV data
        function processCSVData(data) {
            if (data.length === 0) {
                showError('No data found in the CSV file');
                return;
            }

            // Get headers from the first row keys
            headers = Object.keys(data[0]);
            
            // Process each row
            allData = data.map((row, index) => {
                const rowData = {};
                headers.forEach(header => {
                    rowData[header] = row[header] || '';
                });
                rowData._id = index;
                rowData._rowNumber = index + 2; // +2 because CSV has header row
                return rowData;
            });
            
            console.log('Available columns from CSV:', headers);
            console.log(`Loaded ${allData.length} properties from CSV`);
            
            // Continue with data processing
            processDataAfterLoad();
        }

        async function processDataAfterLoad() {
            filteredData = [...allData];
            displayResults(); // Display results immediately
            await plotPoints();
            
            showStatusMessage(`Successfully loaded ${allData.length} properties from CSV`, 'success');
        }

        async function plotPoints() {
            // Clear existing markers
            markers.forEach(marker => marker.setMap(null));
            infoWindows.forEach(iw => iw.close());
            markers = [];
            infoWindows = [];
            
            const latCol = findColumn(['Latitude', 'lat', 'latitude']);
            const lngCol = findColumn(['Longitude', 'lng', 'lon', 'longitude']);
            const addressCol = findColumn(['Location', 'address', 'location']);
            const nameCol = findColumn(['Project_Name', 'name', 'title', 'property']);
            const bhkCol = findColumn(['BHK', 'bhk']);
            const priceCol = findColumn(['Rent', 'rent', 'price']);
            const areaCol = findColumn(['Area', 'area', 'locality']);
            
            if (!latCol || !lngCol) {
                console.error('Latitude or Longitude columns not found');
                return;
            }
            
            let validPoints = 0;
            const bounds = new google.maps.LatLngBounds();
            
            // Add markers for important locations (if in match finder mode)
            if (matchResults.length > 0 && Object.keys(importantLocations).length > 0) {
                Object.keys(importantLocations).forEach(type => {
                    if (importantLocations[type]) {
                        const location = importantLocations[type];
                        const icon = locationTypes[type]?.icon || '📍';
                        const title = locationTypes[type]?.label || type;
                        
                        const marker = new google.maps.Marker({
                            position: { lat: location.lat, lng: location.lng },
                            map: map,
                            title: `${title}: ${location.address}`,
                            icon: {
                                url: `data:image/svg+xml;charset=UTF-8,<svg width="30" height="30" xmlns="http://www.w3.org/2000/svg"><text x="15" y="20" font-size="20" text-anchor="middle">${icon}</text></svg>`,
                                scaledSize: new google.maps.Size(30, 30),
                                anchor: new google.maps.Point(15, 15)
                            }
                        });
                        
                        markers.push(marker);
                    }
                });
            }
            
            for (const row of filteredData) {
                let lat = parseFloat(row[latCol]);
                let lng = parseFloat(row[lngCol]);
                
                if (!lat || !lng || isNaN(lat) || isNaN(lng)) {
                    continue;
                }
                
                const position = { lat, lng };
                const area = row[areaCol];
                const actualRent = parsePrice(row[priceCol]);
                
                // Check if this property has a match score (from Property Match Finder)
                const matchScore = row.matchScore || 0;
                const matchCategory = row.matchCategory || '';
                
                let markerColor = '#667eea';
                let markerText = formatPriceShort(actualRent);
                
                // If in match finder mode, use match score for coloring
                if (matchResults.length > 0 && matchScore > 0) {
                    if (matchScore >= 80) markerColor = '#4ECDC4';
                    else if (matchScore >= 60) markerColor = '#FFD700';
                    else markerColor = '#FF6B6B';
                    
                    markerText = `${matchScore}%`;
                }
                
                const marker = new google.maps.Marker({
                    position: position,
                    map: map,
                    title: `${row[nameCol]} - ${area}`,
                    icon: {
                        url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
                            <svg width="36" height="24" viewBox="0 0 36 24" xmlns="http://www.w3.org/2000/svg">
                                <rect width="36" height="24" rx="5" ry="5" fill="${markerColor}" stroke="white" stroke-width="2"/>
                                <text x="18" y="15" text-anchor="middle" font-size="10" fill="white" font-weight="bold" font-family="Arial">${markerText}</text>
                            </svg>
                        `),
                        scaledSize: new google.maps.Size(36, 24),
                        anchor: new google.maps.Point(18, 12)
                    }
                });
                
                const infoContent = `
                    <div style="min-width: 250px; padding: 10px;">
                        <h3 style="margin: 0 0 8px 0; color: #333;">${row[nameCol] || 'Property'}</h3>
                        ${actualRent ? `
                            <div style="background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%); padding: 10px; border-radius: 8px; margin-bottom: 8px;">
                                <strong>Actual Rent:</strong> ₹${formatPrice(actualRent)}<br>
                                ${matchScore > 0 ? `<br><strong>Match Score:</strong> ${matchScore}%` : ''}
                            </div>
                        ` : ''}
                        ${bhkCol && row[bhkCol] ? `<p style="margin: 5px 0;"><strong>BHK:</strong> ${row[bhkCol]}</p>` : ''}
                        ${areaCol && row[areaCol] ? `<p style="margin: 5px 0;"><strong>Area:</strong> ${row[areaCol]}</p>` : ''}
                        ${addressCol && row[addressCol] ? `<p style="margin: 5px 0;"><strong>Address:</strong> ${row[addressCol]}</p>` : ''}
                        ${matchScore > 0 && row.distances ? `
                            <div style="font-size: 0.9rem; margin-top: 8px;">
                                <strong>Distances:</strong><br>
                                ${Object.keys(row.distances).map(locationType => {
                                    if (row.distances[locationType]) {
                                        const icon = locationTypes[locationType]?.icon || '📍';
                                        const label = locationTypes[locationType]?.label || locationType;
                                        return `${icon} ${label}: ${row.distances[locationType].toFixed(1)} km<br>`;
                                    }
                                    return '';
                                }).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
                
                const infoWindow = new google.maps.InfoWindow({
                    content: infoContent
                });
                
                marker.addListener('click', () => {
                    infoWindows.forEach(iw => iw.close());
                    infoWindow.open(map, marker);
                });
                
                markers.push(marker);
                infoWindows.push(infoWindow);
                bounds.extend(position);
                validPoints++;
            }
            
            if (markers.length > 0) {
                map.fitBounds(bounds);
            }
            
            updateStats(filteredData.length, validPoints);
        }
        
        function parsePrice(price) {
            if (!price) return 0;
            if (typeof price === 'string') {
                return parseFloat(price.replace(/[^0-9.]/g, ''));
            }
            return parseFloat(price);
        }
        
        function formatPrice(price) {
            return Math.round(parsePrice(price)).toLocaleString('en-IN');
        }
        
        function formatPriceShort(price) {
            price = parsePrice(price);
            if (price >= 100000) {
                return (price / 100000).toFixed(1) + 'L';
            } else if (price >= 1000) {
                return (price / 1000).toFixed(0) + 'K';
            }
            return price.toString();
        }

        function displayResults() {
            const resultsDiv = document.getElementById('results');
            
            if (filteredData.length === 0) {
                resultsDiv.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">No properties found</div>';
                return;
            }
            
            const nameCol = findColumn(['Project_Name', 'name', 'title', 'property']);
            const addressCol = findColumn(['Location', 'address', 'location']);
            const priceCol = findColumn(['Rent', 'rent', 'price']);
            const areaCol = findColumn(['Area', 'area', 'locality']);
            const bhkCol = findColumn(['BHK', 'bhk']);
            const furnishedCol = findColumn(['Furnishing', 'furnished', 'furnish']);
            const parkingCol = findColumn(['Parking', 'parking']);
            const amenitiesCol = findColumn(['Amenities', 'amenities', 'amenity']);
            const carAreaCol = findColumn(['Carpet Area', 'carpet area', 'CarArea', 'Carpet_Area']);
            
            const html = filteredData.map(row => {
                const area = row[areaCol];
                const rent = parsePrice(row[priceCol]);
                const totalParking = calculateTotalParking(row[parkingCol]);
                const matchScore = row.matchScore || 0;
                const matchCategory = row.matchCategory || '';
                
                // Clean up the name and address
                const rawName = nameCol && row[nameCol] ? row[nameCol].trim() : '';
                const rawAddress = addressCol && row[addressCol] ? row[addressCol].trim() : '';

                // Treat "Not Specified" or "NA" or "N/A" as missing
                const isInvalidName = !rawName || 
                                      rawName.toLowerCase() === 'not specified' || 
                                      rawName.toLowerCase() === 'na' || 
                                      rawName.toLowerCase() === 'n/a';

                // Use Location (address) when Project_Name is not specified
                const displayName = !isInvalidName ? rawName : (rawAddress || 'Property');
                
                let amenitiesHTML = '';
                if (amenitiesCol && row[amenitiesCol]) {
                    const amenitiesList = parseAmenities(row[amenitiesCol]);
                    // Show first 5 amenities
                    amenitiesHTML = `
                        <div class="property-amenities">
                            ${amenitiesList.slice(0, 5).map(a => `<span class="amenity-tag-small">${a}</span>`).join('')}
                            ${amenitiesList.length > 5 ? `<span class="amenity-tag-small">+${amenitiesList.length - 5} more</span>` : ''}
                        </div>
                    `;
                }
                
                // Add proximity information if available (from match finder)
                let proximityHTML = '';
                if (matchScore > 0 && row.distances) {
                    const locationItems = Object.keys(row.distances || {}).map(locationType => {
                        if (row.distances[locationType]) {
                            const icon = locationTypes[locationType]?.icon || '📍';
                            return `
                                <div class="proximity-item">
                                    <span>${icon} ${locationTypes[locationType]?.label || locationType}:</span>
                                    <span class="proximity-distance">${row.distances[locationType].toFixed(1)} km</span>
                                </div>
                            `;
                        }
                        return '';
                    }).join('');
                    
                    proximityHTML = `
                        <div class="property-proximity">
                            ${locationItems}
                        </div>
                    `;
                }
                
                return `
                    <div class="property-card ${matchCategory}" style="border-left-color: #667eea">
                        ${matchScore > 0 ? `<span class="match-score">${matchScore}% Match</span>` : ''}
                        <div class='property-name1'>
                        <div class="property-name">${displayName}</div>
                        <div class="property-rent">₹${formatPrice(rent)}/month</div>
                        </div>
                        <div class="property-details">
                            ${bhkCol && row[bhkCol] ? `<span class="detail-tag">${row[bhkCol]} BHK</span>` : ''}
                            ${carAreaCol && row[carAreaCol] ? `<span class="detail-tag">${row[carAreaCol]}</span>` : ''}
                            ${areaCol && row[areaCol] ? `<span class="detail-tag">${area}</span>` : ''}
                            ${furnishedCol && row[furnishedCol] ? `<span class="detail-tag">${row[furnishedCol]}</span>` : ''}
                            ${totalParking > 0 ? `<span class="detail-tag">${totalParking} Parking</span>` : ''}
                        </div>
                        ${amenitiesHTML}
                        ${proximityHTML}
                    </div>
                `;
            }).join('');
            
            resultsDiv.innerHTML = html;
        }
        
        function updateStats(total, visible) {
            const statsDiv = document.getElementById('stats');
            
            if (matchResults.length > 0) {
                statsDiv.innerHTML = `
                    <strong>Showing ${visible} properties with 60%+ match score</strong><br>
                    <small>Based on proximity to your important locations</small>
                `;
            } else {
                statsDiv.innerHTML = `
                    <strong>Showing ${visible} of ${total} properties</strong><br>
                    <small>Enter your important locations to find matching properties</small>
                `;
            }
        }
        
        function calculateTotalParking(parkingStr) {
            if (!parkingStr) return 0;
            
            const numbers = parkingStr.match(/\d+/g);
            if (!numbers) return 0;
            
            return numbers.reduce((total, num) => total + parseInt(num), 0);
        }
        
        function parseAmenities(amenitiesStr) {
            if (!amenitiesStr) return [];
            amenitiesStr = amenitiesStr.replace(/[\[\]']/g, '');
            return amenitiesStr.split(',').map(a => a.trim()).filter(a => a.length > 0);
        }
        
        function showError(message) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = `<div class="error">${message}</div>`;
        }

        function showStatusMessage(message, type = 'info') {
            const statusDiv = document.getElementById('statusMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'status-message';
            
            if (type === 'error') {
                messageDiv.style.background = '#ffe6e6';
                messageDiv.style.color = '#d63031';
                messageDiv.style.borderLeftColor = '#d63031';
            } else if (type === 'success') {
                messageDiv.style.background = '#e6f7e6';
                messageDiv.style.color = '#27ae60';
                messageDiv.style.borderLeftColor = '#27ae60';
            } else if (type === 'warning') {
                messageDiv.style.background = '#fff8e6';
                messageDiv.style.color = '#f39c12';
                messageDiv.style.borderLeftColor = '#f39c12';
            }
            
            messageDiv.textContent = message;
            statusDiv.appendChild(messageDiv);
            
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.parentNode.removeChild(messageDiv);
                }
            }, 5000);
        }

        // Show loading indicator for match finder
        function showLoading() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = `
                <div class="loading">
                    <div style="border: 4px solid #f3f3f3; border-top: 4px solid #667eea; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 0 auto 15px;"></div>
                    <p>Analyzing properties based on your location preferences...</p>
                </div>
            `;
        }
        
        // Error handling for Google Maps API
        window.gm_authFailure = function() {
            showStatusMessage('Google Maps authentication failed. Please check your API key.', 'error');
        };
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBBcaIOoP7kpoXy1sDs2MHX1yj92bzBbGo&callback=initMap&libraries=places,geometry"></script>
</body>
</html>